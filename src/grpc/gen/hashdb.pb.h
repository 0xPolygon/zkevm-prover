// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hashdb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_hashdb_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hashdb_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_hashdb_2eproto;
namespace hashdb {
namespace v1 {
class FeList;
struct FeListDefaultTypeInternal;
extern FeListDefaultTypeInternal _FeList_default_instance_;
class Fea;
struct FeaDefaultTypeInternal;
extern FeaDefaultTypeInternal _Fea_default_instance_;
class FlushResponse;
struct FlushResponseDefaultTypeInternal;
extern FlushResponseDefaultTypeInternal _FlushResponse_default_instance_;
class GetFlushDataRequest;
struct GetFlushDataRequestDefaultTypeInternal;
extern GetFlushDataRequestDefaultTypeInternal _GetFlushDataRequest_default_instance_;
class GetFlushDataResponse;
struct GetFlushDataResponseDefaultTypeInternal;
extern GetFlushDataResponseDefaultTypeInternal _GetFlushDataResponse_default_instance_;
class GetFlushDataResponse_NodesEntry_DoNotUse;
struct GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_NodesEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_;
class GetFlushDataResponse_ProgramEntry_DoNotUse;
struct GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal;
extern GetFlushDataResponse_ProgramEntry_DoNotUseDefaultTypeInternal _GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_;
class GetFlushStatusResponse;
struct GetFlushStatusResponseDefaultTypeInternal;
extern GetFlushStatusResponseDefaultTypeInternal _GetFlushStatusResponse_default_instance_;
class GetProgramRequest;
struct GetProgramRequestDefaultTypeInternal;
extern GetProgramRequestDefaultTypeInternal _GetProgramRequest_default_instance_;
class GetProgramResponse;
struct GetProgramResponseDefaultTypeInternal;
extern GetProgramResponseDefaultTypeInternal _GetProgramResponse_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class GetResponse_DbReadLogEntry_DoNotUse;
struct GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _GetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class GetResponse_SiblingsEntry_DoNotUse;
struct GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern GetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _GetResponse_SiblingsEntry_DoNotUse_default_instance_;
class LoadDBRequest;
struct LoadDBRequestDefaultTypeInternal;
extern LoadDBRequestDefaultTypeInternal _LoadDBRequest_default_instance_;
class LoadDBRequest_InputDbEntry_DoNotUse;
struct LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal;
extern LoadDBRequest_InputDbEntry_DoNotUseDefaultTypeInternal _LoadDBRequest_InputDbEntry_DoNotUse_default_instance_;
class LoadProgramDBRequest;
struct LoadProgramDBRequestDefaultTypeInternal;
extern LoadProgramDBRequestDefaultTypeInternal _LoadProgramDBRequest_default_instance_;
class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse;
struct LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal;
extern LoadProgramDBRequest_InputProgramDbEntry_DoNotUseDefaultTypeInternal _LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_;
class ResultCode;
struct ResultCodeDefaultTypeInternal;
extern ResultCodeDefaultTypeInternal _ResultCode_default_instance_;
class SetProgramRequest;
struct SetProgramRequestDefaultTypeInternal;
extern SetProgramRequestDefaultTypeInternal _SetProgramRequest_default_instance_;
class SetProgramResponse;
struct SetProgramResponseDefaultTypeInternal;
extern SetProgramResponseDefaultTypeInternal _SetProgramResponse_default_instance_;
class SetRequest;
struct SetRequestDefaultTypeInternal;
extern SetRequestDefaultTypeInternal _SetRequest_default_instance_;
class SetResponse;
struct SetResponseDefaultTypeInternal;
extern SetResponseDefaultTypeInternal _SetResponse_default_instance_;
class SetResponse_DbReadLogEntry_DoNotUse;
struct SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_DbReadLogEntry_DoNotUseDefaultTypeInternal _SetResponse_DbReadLogEntry_DoNotUse_default_instance_;
class SetResponse_SiblingsEntry_DoNotUse;
struct SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal;
extern SetResponse_SiblingsEntry_DoNotUseDefaultTypeInternal _SetResponse_SiblingsEntry_DoNotUse_default_instance_;
class SiblingList;
struct SiblingListDefaultTypeInternal;
extern SiblingListDefaultTypeInternal _SiblingList_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace hashdb
PROTOBUF_NAMESPACE_OPEN
template <>
::hashdb::v1::FeList* Arena::CreateMaybeMessage<::hashdb::v1::FeList>(Arena*);
template <>
::hashdb::v1::Fea* Arena::CreateMaybeMessage<::hashdb::v1::Fea>(Arena*);
template <>
::hashdb::v1::FlushResponse* Arena::CreateMaybeMessage<::hashdb::v1::FlushResponse>(Arena*);
template <>
::hashdb::v1::GetFlushDataRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataRequest>(Arena*);
template <>
::hashdb::v1::GetFlushDataResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse>(Arena*);
template <>
::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_NodesEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushDataResponse_ProgramEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::GetFlushStatusResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetFlushStatusResponse>(Arena*);
template <>
::hashdb::v1::GetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramRequest>(Arena*);
template <>
::hashdb::v1::GetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetProgramResponse>(Arena*);
template <>
::hashdb::v1::GetRequest* Arena::CreateMaybeMessage<::hashdb::v1::GetRequest>(Arena*);
template <>
::hashdb::v1::GetResponse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse>(Arena*);
template <>
::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::GetResponse_SiblingsEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::LoadDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest>(Arena*);
template <>
::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadDBRequest_InputDbEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::LoadProgramDBRequest* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest>(Arena*);
template <>
::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::LoadProgramDBRequest_InputProgramDbEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::ResultCode* Arena::CreateMaybeMessage<::hashdb::v1::ResultCode>(Arena*);
template <>
::hashdb::v1::SetProgramRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramRequest>(Arena*);
template <>
::hashdb::v1::SetProgramResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetProgramResponse>(Arena*);
template <>
::hashdb::v1::SetRequest* Arena::CreateMaybeMessage<::hashdb::v1::SetRequest>(Arena*);
template <>
::hashdb::v1::SetResponse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse>(Arena*);
template <>
::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_DbReadLogEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse* Arena::CreateMaybeMessage<::hashdb::v1::SetResponse_SiblingsEntry_DoNotUse>(Arena*);
template <>
::hashdb::v1::SiblingList* Arena::CreateMaybeMessage<::hashdb::v1::SiblingList>(Arena*);
template <>
::hashdb::v1::Version* Arena::CreateMaybeMessage<::hashdb::v1::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace hashdb {
namespace v1 {
enum ResultCode_Code : int {
  ResultCode_Code_CODE_UNSPECIFIED = 0,
  ResultCode_Code_CODE_SUCCESS = 1,
  ResultCode_Code_CODE_DB_KEY_NOT_FOUND = 2,
  ResultCode_Code_CODE_DB_ERROR = 3,
  ResultCode_Code_CODE_INTERNAL_ERROR = 4,
  ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE = 14,
  ResultCode_Code_ResultCode_Code_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ResultCode_Code_ResultCode_Code_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ResultCode_Code_IsValid(int value);
constexpr ResultCode_Code ResultCode_Code_Code_MIN = static_cast<ResultCode_Code>(0);
constexpr ResultCode_Code ResultCode_Code_Code_MAX = static_cast<ResultCode_Code>(14);
constexpr int ResultCode_Code_Code_ARRAYSIZE = 14 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ResultCode_Code_descriptor();
template <typename T>
const std::string& ResultCode_Code_Name(T value) {
  static_assert(std::is_same<T, ResultCode_Code>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Code_Name().");
  return ResultCode_Code_Name(static_cast<ResultCode_Code>(value));
}
template <>
inline const std::string& ResultCode_Code_Name(ResultCode_Code value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ResultCode_Code_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool ResultCode_Code_Parse(absl::string_view name, ResultCode_Code* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResultCode_Code>(
      ResultCode_Code_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1() ;
  const std::string& v0_0_1() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_v0_0_1(Arg_&& arg, Args_... args);
  std::string* mutable_v0_0_1();
  PROTOBUF_NODISCARD std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* ptr);

  private:
  const std::string& _internal_v0_0_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v0_0_1(
      const std::string& value);
  std::string* _internal_mutable_v0_0_1();

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v0_0_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class SetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetRequest) */ {
 public:
  inline SetRequest() : SetRequest(nullptr) {}
  ~SetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetRequest(const SetRequest& from);
  SetRequest(SetRequest&& from) noexcept
    : SetRequest() {
    *this = ::std::move(from);
  }

  inline SetRequest& operator=(const SetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequest& operator=(SetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetRequest* internal_default_instance() {
    return reinterpret_cast<const SetRequest*>(
               &_SetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetRequest& a, SetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetRequest& from) {
    SetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.SetRequest";
  }
  protected:
  explicit SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kOldRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kPersistentFieldNumber = 4,
    kDetailsFieldNumber = 5,
    kGetDbReadLogFieldNumber = 6,
  };
  // string value = 3;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  void clear_old_root() ;
  const ::hashdb::v1::Fea& old_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();
  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  void clear_key() ;
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();
  // bool persistent = 4;
  void clear_persistent() ;
  bool persistent() const;
  void set_persistent(bool value);

  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);

  public:
  // bool details = 5;
  void clear_details() ;
  bool details() const;
  void set_details(bool value);

  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);

  public:
  // bool get_db_read_log = 6;
  void clear_get_db_read_log() ;
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);

  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.SetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::hashdb::v1::Fea* old_root_;
    ::hashdb::v1::Fea* key_;
    bool persistent_;
    bool details_;
    bool get_db_read_log_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRequest& from) {
    GetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kDetailsFieldNumber = 3,
    kGetDbReadLogFieldNumber = 4,
  };
  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  void clear_root() ;
  const ::hashdb::v1::Fea& root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();
  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  void clear_key() ;
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();
  // bool details = 3;
  void clear_details() ;
  bool details() const;
  void set_details(bool value);

  private:
  bool _internal_details() const;
  void _internal_set_details(bool value);

  public:
  // bool get_db_read_log = 4;
  void clear_get_db_read_log() ;
  bool get_db_read_log() const;
  void set_get_db_read_log(bool value);

  private:
  bool _internal_get_db_read_log() const;
  void _internal_set_get_db_read_log(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hashdb::v1::Fea* root_;
    ::hashdb::v1::Fea* key_;
    bool details_;
    bool get_db_read_log_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class SetProgramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramRequest) */ {
 public:
  inline SetProgramRequest() : SetProgramRequest(nullptr) {}
  ~SetProgramRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetProgramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProgramRequest(const SetProgramRequest& from);
  SetProgramRequest(SetProgramRequest&& from) noexcept
    : SetProgramRequest() {
    *this = ::std::move(from);
  }

  inline SetProgramRequest& operator=(const SetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramRequest& operator=(SetProgramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProgramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const SetProgramRequest*>(
               &_SetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetProgramRequest& a, SetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProgramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProgramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetProgramRequest& from) {
    SetProgramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.SetProgramRequest";
  }
  protected:
  explicit SetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKeyFieldNumber = 1,
    kPersistentFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  void clear_key() ;
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();
  // bool persistent = 3;
  void clear_persistent() ;
  bool persistent() const;
  void set_persistent(bool value);

  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::hashdb::v1::Fea* key_;
    bool persistent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetProgramRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramRequest) */ {
 public:
  inline GetProgramRequest() : GetProgramRequest(nullptr) {}
  ~GetProgramRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProgramRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProgramRequest(const GetProgramRequest& from);
  GetProgramRequest(GetProgramRequest&& from) noexcept
    : GetProgramRequest() {
    *this = ::std::move(from);
  }

  inline GetProgramRequest& operator=(const GetProgramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramRequest& operator=(GetProgramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProgramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProgramRequest* internal_default_instance() {
    return reinterpret_cast<const GetProgramRequest*>(
               &_GetProgramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetProgramRequest& a, GetProgramRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProgramRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProgramRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProgramRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProgramRequest& from) {
    GetProgramRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetProgramRequest";
  }
  protected:
  explicit GetProgramRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // .hashdb.v1.Fea key = 1;
  bool has_key() const;
  void clear_key() ;
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hashdb::v1::Fea* key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class LoadDBRequest_InputDbEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadDBRequest_InputDbEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  LoadDBRequest_InputDbEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadDBRequest_InputDbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadDBRequest_InputDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadDBRequest_InputDbEntry_DoNotUse& other);
  static const LoadDBRequest_InputDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadDBRequest_InputDbEntry_DoNotUse*>(&_LoadDBRequest_InputDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadDBRequest.InputDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadDBRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadDBRequest) */ {
 public:
  inline LoadDBRequest() : LoadDBRequest(nullptr) {}
  ~LoadDBRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadDBRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadDBRequest(const LoadDBRequest& from);
  LoadDBRequest(LoadDBRequest&& from) noexcept
    : LoadDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadDBRequest& operator=(const LoadDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadDBRequest& operator=(LoadDBRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadDBRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadDBRequest*>(
               &_LoadDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoadDBRequest& a, LoadDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadDBRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadDBRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadDBRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadDBRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadDBRequest& from) {
    LoadDBRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadDBRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.LoadDBRequest";
  }
  protected:
  explicit LoadDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, .hashdb.v1.FeList> input_db = 1;
  int input_db_size() const;
  private:
  int _internal_input_db_size() const;

  public:
  void clear_input_db() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_input_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      input_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_input_db();
  // bool persistent = 2;
  void clear_persistent() ;
  bool persistent() const;
  void set_persistent(bool value);

  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadDBRequest_InputDbEntry_DoNotUse,
        std::string, ::hashdb::v1::FeList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> input_db_;
    bool persistent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class LoadProgramDBRequest_InputProgramDbEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<LoadProgramDBRequest_InputProgramDbEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  LoadProgramDBRequest_InputProgramDbEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit LoadProgramDBRequest_InputProgramDbEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse& other);
  static const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const LoadProgramDBRequest_InputProgramDbEntry_DoNotUse*>(&_LoadProgramDBRequest_InputProgramDbEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.LoadProgramDBRequest.InputProgramDbEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class LoadProgramDBRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.LoadProgramDBRequest) */ {
 public:
  inline LoadProgramDBRequest() : LoadProgramDBRequest(nullptr) {}
  ~LoadProgramDBRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadProgramDBRequest(const LoadProgramDBRequest& from);
  LoadProgramDBRequest(LoadProgramDBRequest&& from) noexcept
    : LoadProgramDBRequest() {
    *this = ::std::move(from);
  }

  inline LoadProgramDBRequest& operator=(const LoadProgramDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadProgramDBRequest& operator=(LoadProgramDBRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadProgramDBRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadProgramDBRequest* internal_default_instance() {
    return reinterpret_cast<const LoadProgramDBRequest*>(
               &_LoadProgramDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LoadProgramDBRequest& a, LoadProgramDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadProgramDBRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadProgramDBRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadProgramDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadProgramDBRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadProgramDBRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoadProgramDBRequest& from) {
    LoadProgramDBRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadProgramDBRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.LoadProgramDBRequest";
  }
  protected:
  explicit LoadProgramDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInputProgramDbFieldNumber = 1,
    kPersistentFieldNumber = 2,
  };
  // map<string, bytes> input_program_db = 1;
  int input_program_db_size() const;
  private:
  int _internal_input_program_db_size() const;

  public:
  void clear_input_program_db() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_input_program_db();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      input_program_db() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_input_program_db();
  // bool persistent = 2;
  void clear_persistent() ;
  bool persistent() const;
  void set_persistent(bool value);

  private:
  bool _internal_persistent() const;
  void _internal_set_persistent(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.LoadProgramDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        LoadProgramDBRequest_InputProgramDbEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> input_program_db_;
    bool persistent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetFlushDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataRequest) */ {
 public:
  inline GetFlushDataRequest() : GetFlushDataRequest(nullptr) {}
  ~GetFlushDataRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushDataRequest(const GetFlushDataRequest& from);
  GetFlushDataRequest(GetFlushDataRequest&& from) noexcept
    : GetFlushDataRequest() {
    *this = ::std::move(from);
  }

  inline GetFlushDataRequest& operator=(const GetFlushDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataRequest& operator=(GetFlushDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushDataRequest* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataRequest*>(
               &_GetFlushDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetFlushDataRequest& a, GetFlushDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushDataRequest& from) {
    GetFlushDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetFlushDataRequest";
  }
  protected:
  explicit GetFlushDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlushIdFieldNumber = 1,
  };
  // uint64 flush_id = 1;
  void clear_flush_id() ;
  ::uint64_t flush_id() const;
  void set_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t flush_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class SetResponse_SiblingsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    ::uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_SiblingsEntry_DoNotUse, 
    ::uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SetResponse_SiblingsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetResponse_SiblingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_SiblingsEntry_DoNotUse& other);
  static const SetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_SiblingsEntry_DoNotUse*>(&_SetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetResponse_DbReadLogEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SetResponse_DbReadLogEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetResponse_DbReadLogEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetResponse_DbReadLogEntry_DoNotUse& other);
  static const SetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetResponse_DbReadLogEntry_DoNotUse*>(&_SetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.SetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class SetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetResponse) */ {
 public:
  inline SetResponse() : SetResponse(nullptr) {}
  ~SetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetResponse(const SetResponse& from);
  SetResponse(SetResponse&& from) noexcept
    : SetResponse() {
    *this = ::std::move(from);
  }

  inline SetResponse& operator=(const SetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetResponse& operator=(SetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetResponse* internal_default_instance() {
    return reinterpret_cast<const SetResponse*>(
               &_SetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetResponse& a, SetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetResponse& from) {
    SetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.SetResponse";
  }
  protected:
  explicit SetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 4,
    kDbReadLogFieldNumber = 12,
    kInsValueFieldNumber = 6,
    kOldValueFieldNumber = 8,
    kNewValueFieldNumber = 9,
    kModeFieldNumber = 10,
    kOldRootFieldNumber = 1,
    kNewRootFieldNumber = 2,
    kKeyFieldNumber = 3,
    kInsKeyFieldNumber = 5,
    kResultFieldNumber = 13,
    kProofHashCounterFieldNumber = 11,
    kIsOld0FieldNumber = 7,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 4;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;

  public:
  void clear_siblings() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
      mutable_siblings();
  // map<string, .hashdb.v1.FeList> db_read_log = 12;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;

  public:
  void clear_db_read_log() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();
  // string ins_value = 6;
  void clear_ins_value() ;
  const std::string& ins_value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ins_value(Arg_&& arg, Args_... args);
  std::string* mutable_ins_value();
  PROTOBUF_NODISCARD std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ptr);

  private:
  const std::string& _internal_ins_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ins_value(
      const std::string& value);
  std::string* _internal_mutable_ins_value();

  public:
  // string old_value = 8;
  void clear_old_value() ;
  const std::string& old_value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_old_value(Arg_&& arg, Args_... args);
  std::string* mutable_old_value();
  PROTOBUF_NODISCARD std::string* release_old_value();
  void set_allocated_old_value(std::string* ptr);

  private:
  const std::string& _internal_old_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_value(
      const std::string& value);
  std::string* _internal_mutable_old_value();

  public:
  // string new_value = 9;
  void clear_new_value() ;
  const std::string& new_value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_value(Arg_&& arg, Args_... args);
  std::string* mutable_new_value();
  PROTOBUF_NODISCARD std::string* release_new_value();
  void set_allocated_new_value(std::string* ptr);

  private:
  const std::string& _internal_new_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_value(
      const std::string& value);
  std::string* _internal_mutable_new_value();

  public:
  // string mode = 10;
  void clear_mode() ;
  const std::string& mode() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mode(Arg_&& arg, Args_... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* ptr);

  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(
      const std::string& value);
  std::string* _internal_mutable_mode();

  public:
  // .hashdb.v1.Fea old_root = 1;
  bool has_old_root() const;
  void clear_old_root() ;
  const ::hashdb::v1::Fea& old_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_old_root();
  ::hashdb::v1::Fea* mutable_old_root();
  void set_allocated_old_root(::hashdb::v1::Fea* old_root);
  private:
  const ::hashdb::v1::Fea& _internal_old_root() const;
  ::hashdb::v1::Fea* _internal_mutable_old_root();
  public:
  void unsafe_arena_set_allocated_old_root(
      ::hashdb::v1::Fea* old_root);
  ::hashdb::v1::Fea* unsafe_arena_release_old_root();
  // .hashdb.v1.Fea new_root = 2;
  bool has_new_root() const;
  void clear_new_root() ;
  const ::hashdb::v1::Fea& new_root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_new_root();
  ::hashdb::v1::Fea* mutable_new_root();
  void set_allocated_new_root(::hashdb::v1::Fea* new_root);
  private:
  const ::hashdb::v1::Fea& _internal_new_root() const;
  ::hashdb::v1::Fea* _internal_mutable_new_root();
  public:
  void unsafe_arena_set_allocated_new_root(
      ::hashdb::v1::Fea* new_root);
  ::hashdb::v1::Fea* unsafe_arena_release_new_root();
  // .hashdb.v1.Fea key = 3;
  bool has_key() const;
  void clear_key() ;
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();
  // .hashdb.v1.Fea ins_key = 5;
  bool has_ins_key() const;
  void clear_ins_key() ;
  const ::hashdb::v1::Fea& ins_key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();
  // .hashdb.v1.ResultCode result = 13;
  bool has_result() const;
  void clear_result() ;
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();
  // uint64 proof_hash_counter = 11;
  void clear_proof_hash_counter() ;
  ::uint64_t proof_hash_counter() const;
  void set_proof_hash_counter(::uint64_t value);

  private:
  ::uint64_t _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(::uint64_t value);

  public:
  // bool is_old0 = 7;
  void clear_is_old0() ;
  bool is_old0() const;
  void set_is_old0(bool value);

  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.SetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetResponse_SiblingsEntry_DoNotUse,
        ::uint64_t, ::hashdb::v1::SiblingList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> siblings_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetResponse_DbReadLogEntry_DoNotUse,
        std::string, ::hashdb::v1::FeList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> db_read_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::hashdb::v1::Fea* old_root_;
    ::hashdb::v1::Fea* new_root_;
    ::hashdb::v1::Fea* key_;
    ::hashdb::v1::Fea* ins_key_;
    ::hashdb::v1::ResultCode* result_;
    ::uint64_t proof_hash_counter_;
    bool is_old0_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetResponse_SiblingsEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    ::uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_SiblingsEntry_DoNotUse, 
    ::uint64_t, ::hashdb::v1::SiblingList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetResponse_SiblingsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponse_SiblingsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetResponse_SiblingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_SiblingsEntry_DoNotUse& other);
  static const GetResponse_SiblingsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_SiblingsEntry_DoNotUse*>(&_GetResponse_SiblingsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetResponse_DbReadLogEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetResponse_DbReadLogEntry_DoNotUse, 
    std::string, ::hashdb::v1::FeList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetResponse_DbReadLogEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponse_DbReadLogEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetResponse_DbReadLogEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetResponse_DbReadLogEntry_DoNotUse& other);
  static const GetResponse_DbReadLogEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetResponse_DbReadLogEntry_DoNotUse*>(&_GetResponse_DbReadLogEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetResponse.DbReadLogEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetResponse& from) {
    GetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSiblingsFieldNumber = 3,
    kDbReadLogFieldNumber = 9,
    kInsValueFieldNumber = 5,
    kValueFieldNumber = 7,
    kRootFieldNumber = 1,
    kKeyFieldNumber = 2,
    kInsKeyFieldNumber = 4,
    kResultFieldNumber = 10,
    kProofHashCounterFieldNumber = 8,
    kIsOld0FieldNumber = 6,
  };
  // map<uint64, .hashdb.v1.SiblingList> siblings = 3;
  int siblings_size() const;
  private:
  int _internal_siblings_size() const;

  public:
  void clear_siblings() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
      _internal_siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
      _internal_mutable_siblings();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
      siblings() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
      mutable_siblings();
  // map<string, .hashdb.v1.FeList> db_read_log = 9;
  int db_read_log_size() const;
  private:
  int _internal_db_read_log_size() const;

  public:
  void clear_db_read_log() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      _internal_db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      _internal_mutable_db_read_log();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
      db_read_log() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
      mutable_db_read_log();
  // string ins_value = 5;
  void clear_ins_value() ;
  const std::string& ins_value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ins_value(Arg_&& arg, Args_... args);
  std::string* mutable_ins_value();
  PROTOBUF_NODISCARD std::string* release_ins_value();
  void set_allocated_ins_value(std::string* ptr);

  private:
  const std::string& _internal_ins_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ins_value(
      const std::string& value);
  std::string* _internal_mutable_ins_value();

  public:
  // string value = 7;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // .hashdb.v1.Fea root = 1;
  bool has_root() const;
  void clear_root() ;
  const ::hashdb::v1::Fea& root() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_root();
  ::hashdb::v1::Fea* mutable_root();
  void set_allocated_root(::hashdb::v1::Fea* root);
  private:
  const ::hashdb::v1::Fea& _internal_root() const;
  ::hashdb::v1::Fea* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::hashdb::v1::Fea* root);
  ::hashdb::v1::Fea* unsafe_arena_release_root();
  // .hashdb.v1.Fea key = 2;
  bool has_key() const;
  void clear_key() ;
  const ::hashdb::v1::Fea& key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_key();
  ::hashdb::v1::Fea* mutable_key();
  void set_allocated_key(::hashdb::v1::Fea* key);
  private:
  const ::hashdb::v1::Fea& _internal_key() const;
  ::hashdb::v1::Fea* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::hashdb::v1::Fea* key);
  ::hashdb::v1::Fea* unsafe_arena_release_key();
  // .hashdb.v1.Fea ins_key = 4;
  bool has_ins_key() const;
  void clear_ins_key() ;
  const ::hashdb::v1::Fea& ins_key() const;
  PROTOBUF_NODISCARD ::hashdb::v1::Fea* release_ins_key();
  ::hashdb::v1::Fea* mutable_ins_key();
  void set_allocated_ins_key(::hashdb::v1::Fea* ins_key);
  private:
  const ::hashdb::v1::Fea& _internal_ins_key() const;
  ::hashdb::v1::Fea* _internal_mutable_ins_key();
  public:
  void unsafe_arena_set_allocated_ins_key(
      ::hashdb::v1::Fea* ins_key);
  ::hashdb::v1::Fea* unsafe_arena_release_ins_key();
  // .hashdb.v1.ResultCode result = 10;
  bool has_result() const;
  void clear_result() ;
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();
  // uint64 proof_hash_counter = 8;
  void clear_proof_hash_counter() ;
  ::uint64_t proof_hash_counter() const;
  void set_proof_hash_counter(::uint64_t value);

  private:
  ::uint64_t _internal_proof_hash_counter() const;
  void _internal_set_proof_hash_counter(::uint64_t value);

  public:
  // bool is_old0 = 6;
  void clear_is_old0() ;
  bool is_old0() const;
  void set_is_old0(bool value);

  private:
  bool _internal_is_old0() const;
  void _internal_set_is_old0(bool value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetResponse_SiblingsEntry_DoNotUse,
        ::uint64_t, ::hashdb::v1::SiblingList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> siblings_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetResponse_DbReadLogEntry_DoNotUse,
        std::string, ::hashdb::v1::FeList,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> db_read_log_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ins_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::hashdb::v1::Fea* root_;
    ::hashdb::v1::Fea* key_;
    ::hashdb::v1::Fea* ins_key_;
    ::hashdb::v1::ResultCode* result_;
    ::uint64_t proof_hash_counter_;
    bool is_old0_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class SetProgramResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SetProgramResponse) */ {
 public:
  inline SetProgramResponse() : SetProgramResponse(nullptr) {}
  ~SetProgramResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetProgramResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProgramResponse(const SetProgramResponse& from);
  SetProgramResponse(SetProgramResponse&& from) noexcept
    : SetProgramResponse() {
    *this = ::std::move(from);
  }

  inline SetProgramResponse& operator=(const SetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProgramResponse& operator=(SetProgramResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProgramResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const SetProgramResponse*>(
               &_SetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SetProgramResponse& a, SetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProgramResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProgramResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProgramResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProgramResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetProgramResponse& from) {
    SetProgramResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProgramResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.SetProgramResponse";
  }
  protected:
  explicit SetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();
  // @@protoc_insertion_point(class_scope:hashdb.v1.SetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hashdb::v1::ResultCode* result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetProgramResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetProgramResponse) */ {
 public:
  inline GetProgramResponse() : GetProgramResponse(nullptr) {}
  ~GetProgramResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetProgramResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetProgramResponse(const GetProgramResponse& from);
  GetProgramResponse(GetProgramResponse&& from) noexcept
    : GetProgramResponse() {
    *this = ::std::move(from);
  }

  inline GetProgramResponse& operator=(const GetProgramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProgramResponse& operator=(GetProgramResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetProgramResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetProgramResponse* internal_default_instance() {
    return reinterpret_cast<const GetProgramResponse*>(
               &_GetProgramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetProgramResponse& a, GetProgramResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProgramResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProgramResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetProgramResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetProgramResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetProgramResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetProgramResponse& from) {
    GetProgramResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProgramResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetProgramResponse";
  }
  protected:
  explicit GetProgramResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // .hashdb.v1.ResultCode result = 2;
  bool has_result() const;
  void clear_result() ;
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetProgramResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::hashdb::v1::ResultCode* result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class FlushResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FlushResponse) */ {
 public:
  inline FlushResponse() : FlushResponse(nullptr) {}
  ~FlushResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlushResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushResponse(const FlushResponse& from);
  FlushResponse(FlushResponse&& from) noexcept
    : FlushResponse() {
    *this = ::std::move(from);
  }

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushResponse& operator=(FlushResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushResponse* internal_default_instance() {
    return reinterpret_cast<const FlushResponse*>(
               &_FlushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FlushResponse& a, FlushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlushResponse& from) {
    FlushResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.FlushResponse";
  }
  protected:
  explicit FlushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kFlushIdFieldNumber = 1,
    kStoredFlushIdFieldNumber = 2,
  };
  // .hashdb.v1.ResultCode result = 3;
  bool has_result() const;
  void clear_result() ;
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();
  // uint64 flush_id = 1;
  void clear_flush_id() ;
  ::uint64_t flush_id() const;
  void set_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_flush_id() const;
  void _internal_set_flush_id(::uint64_t value);

  public:
  // uint64 stored_flush_id = 2;
  void clear_stored_flush_id() ;
  ::uint64_t stored_flush_id() const;
  void set_stored_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.FlushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::hashdb::v1::ResultCode* result_;
    ::uint64_t flush_id_;
    ::uint64_t stored_flush_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetFlushStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushStatusResponse) */ {
 public:
  inline GetFlushStatusResponse() : GetFlushStatusResponse(nullptr) {}
  ~GetFlushStatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushStatusResponse(const GetFlushStatusResponse& from);
  GetFlushStatusResponse(GetFlushStatusResponse&& from) noexcept
    : GetFlushStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushStatusResponse& operator=(const GetFlushStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushStatusResponse& operator=(GetFlushStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushStatusResponse*>(
               &_GetFlushStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetFlushStatusResponse& a, GetFlushStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushStatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushStatusResponse& from) {
    GetFlushStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetFlushStatusResponse";
  }
  protected:
  explicit GetFlushStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProverIdFieldNumber = 8,
    kStoredFlushIdFieldNumber = 1,
    kStoringFlushIdFieldNumber = 2,
    kLastFlushIdFieldNumber = 3,
    kPendingToFlushNodesFieldNumber = 4,
    kPendingToFlushProgramFieldNumber = 5,
    kStoringNodesFieldNumber = 6,
    kStoringProgramFieldNumber = 7,
  };
  // string prover_id = 8;
  void clear_prover_id() ;
  const std::string& prover_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prover_id(Arg_&& arg, Args_... args);
  std::string* mutable_prover_id();
  PROTOBUF_NODISCARD std::string* release_prover_id();
  void set_allocated_prover_id(std::string* ptr);

  private:
  const std::string& _internal_prover_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prover_id(
      const std::string& value);
  std::string* _internal_mutable_prover_id();

  public:
  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id() ;
  ::uint64_t stored_flush_id() const;
  void set_stored_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::uint64_t value);

  public:
  // uint64 storing_flush_id = 2;
  void clear_storing_flush_id() ;
  ::uint64_t storing_flush_id() const;
  void set_storing_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_storing_flush_id() const;
  void _internal_set_storing_flush_id(::uint64_t value);

  public:
  // uint64 last_flush_id = 3;
  void clear_last_flush_id() ;
  ::uint64_t last_flush_id() const;
  void set_last_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_last_flush_id() const;
  void _internal_set_last_flush_id(::uint64_t value);

  public:
  // uint64 pending_to_flush_nodes = 4;
  void clear_pending_to_flush_nodes() ;
  ::uint64_t pending_to_flush_nodes() const;
  void set_pending_to_flush_nodes(::uint64_t value);

  private:
  ::uint64_t _internal_pending_to_flush_nodes() const;
  void _internal_set_pending_to_flush_nodes(::uint64_t value);

  public:
  // uint64 pending_to_flush_program = 5;
  void clear_pending_to_flush_program() ;
  ::uint64_t pending_to_flush_program() const;
  void set_pending_to_flush_program(::uint64_t value);

  private:
  ::uint64_t _internal_pending_to_flush_program() const;
  void _internal_set_pending_to_flush_program(::uint64_t value);

  public:
  // uint64 storing_nodes = 6;
  void clear_storing_nodes() ;
  ::uint64_t storing_nodes() const;
  void set_storing_nodes(::uint64_t value);

  private:
  ::uint64_t _internal_storing_nodes() const;
  void _internal_set_storing_nodes(::uint64_t value);

  public:
  // uint64 storing_program = 7;
  void clear_storing_program() ;
  ::uint64_t storing_program() const;
  void set_storing_program(::uint64_t value);

  private:
  ::uint64_t _internal_storing_program() const;
  void _internal_set_storing_program(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
    ::uint64_t stored_flush_id_;
    ::uint64_t storing_flush_id_;
    ::uint64_t last_flush_id_;
    ::uint64_t pending_to_flush_nodes_;
    ::uint64_t pending_to_flush_program_;
    ::uint64_t storing_nodes_;
    ::uint64_t storing_program_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class GetFlushDataResponse_NodesEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_NodesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetFlushDataResponse_NodesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlushDataResponse_NodesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetFlushDataResponse_NodesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_NodesEntry_DoNotUse& other);
  static const GetFlushDataResponse_NodesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_NodesEntry_DoNotUse*>(&_GetFlushDataResponse_NodesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.NodesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataResponse_ProgramEntry_DoNotUse final : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetFlushDataResponse_ProgramEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetFlushDataResponse_ProgramEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlushDataResponse_ProgramEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetFlushDataResponse_ProgramEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetFlushDataResponse_ProgramEntry_DoNotUse& other);
  static const GetFlushDataResponse_ProgramEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetFlushDataResponse_ProgramEntry_DoNotUse*>(&_GetFlushDataResponse_ProgramEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "hashdb.v1.GetFlushDataResponse.ProgramEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_hashdb_2eproto;
};
// -------------------------------------------------------------------

class GetFlushDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.GetFlushDataResponse) */ {
 public:
  inline GetFlushDataResponse() : GetFlushDataResponse(nullptr) {}
  ~GetFlushDataResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFlushDataResponse(const GetFlushDataResponse& from);
  GetFlushDataResponse(GetFlushDataResponse&& from) noexcept
    : GetFlushDataResponse() {
    *this = ::std::move(from);
  }

  inline GetFlushDataResponse& operator=(const GetFlushDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFlushDataResponse& operator=(GetFlushDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFlushDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFlushDataResponse* internal_default_instance() {
    return reinterpret_cast<const GetFlushDataResponse*>(
               &_GetFlushDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetFlushDataResponse& a, GetFlushDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFlushDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFlushDataResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFlushDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFlushDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFlushDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFlushDataResponse& from) {
    GetFlushDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFlushDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.GetFlushDataResponse";
  }
  protected:
  explicit GetFlushDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 2,
    kProgramFieldNumber = 3,
    kNodesStateRootFieldNumber = 4,
    kResultFieldNumber = 5,
    kStoredFlushIdFieldNumber = 1,
  };
  // map<string, string> nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_nodes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      nodes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_nodes();
  // map<string, string> program = 3;
  int program_size() const;
  private:
  int _internal_program_size() const;

  public:
  void clear_program() ;
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_program();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      program() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_program();
  // string nodes_state_root = 4;
  void clear_nodes_state_root() ;
  const std::string& nodes_state_root() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodes_state_root(Arg_&& arg, Args_... args);
  std::string* mutable_nodes_state_root();
  PROTOBUF_NODISCARD std::string* release_nodes_state_root();
  void set_allocated_nodes_state_root(std::string* ptr);

  private:
  const std::string& _internal_nodes_state_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodes_state_root(
      const std::string& value);
  std::string* _internal_mutable_nodes_state_root();

  public:
  // .hashdb.v1.ResultCode result = 5;
  bool has_result() const;
  void clear_result() ;
  const ::hashdb::v1::ResultCode& result() const;
  PROTOBUF_NODISCARD ::hashdb::v1::ResultCode* release_result();
  ::hashdb::v1::ResultCode* mutable_result();
  void set_allocated_result(::hashdb::v1::ResultCode* result);
  private:
  const ::hashdb::v1::ResultCode& _internal_result() const;
  ::hashdb::v1::ResultCode* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::hashdb::v1::ResultCode* result);
  ::hashdb::v1::ResultCode* unsafe_arena_release_result();
  // uint64 stored_flush_id = 1;
  void clear_stored_flush_id() ;
  ::uint64_t stored_flush_id() const;
  void set_stored_flush_id(::uint64_t value);

  private:
  ::uint64_t _internal_stored_flush_id() const;
  void _internal_set_stored_flush_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.GetFlushDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetFlushDataResponse_NodesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> nodes_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        GetFlushDataResponse_ProgramEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> program_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodes_state_root_;
    ::hashdb::v1::ResultCode* result_;
    ::uint64_t stored_flush_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class Fea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.Fea) */ {
 public:
  inline Fea() : Fea(nullptr) {}
  ~Fea() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fea(const Fea& from);
  Fea(Fea&& from) noexcept
    : Fea() {
    *this = ::std::move(from);
  }

  inline Fea& operator=(const Fea& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fea& operator=(Fea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fea& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fea* internal_default_instance() {
    return reinterpret_cast<const Fea*>(
               &_Fea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Fea& a, Fea& b) {
    a.Swap(&b);
  }
  inline void Swap(Fea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fea* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fea& from) {
    Fea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.Fea";
  }
  protected:
  explicit Fea(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFe0FieldNumber = 1,
    kFe1FieldNumber = 2,
    kFe2FieldNumber = 3,
    kFe3FieldNumber = 4,
  };
  // uint64 fe0 = 1;
  void clear_fe0() ;
  ::uint64_t fe0() const;
  void set_fe0(::uint64_t value);

  private:
  ::uint64_t _internal_fe0() const;
  void _internal_set_fe0(::uint64_t value);

  public:
  // uint64 fe1 = 2;
  void clear_fe1() ;
  ::uint64_t fe1() const;
  void set_fe1(::uint64_t value);

  private:
  ::uint64_t _internal_fe1() const;
  void _internal_set_fe1(::uint64_t value);

  public:
  // uint64 fe2 = 3;
  void clear_fe2() ;
  ::uint64_t fe2() const;
  void set_fe2(::uint64_t value);

  private:
  ::uint64_t _internal_fe2() const;
  void _internal_set_fe2(::uint64_t value);

  public:
  // uint64 fe3 = 4;
  void clear_fe3() ;
  ::uint64_t fe3() const;
  void set_fe3(::uint64_t value);

  private:
  ::uint64_t _internal_fe3() const;
  void _internal_set_fe3(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.Fea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t fe0_;
    ::uint64_t fe1_;
    ::uint64_t fe2_;
    ::uint64_t fe3_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class FeList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.FeList) */ {
 public:
  inline FeList() : FeList(nullptr) {}
  ~FeList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FeList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeList(const FeList& from);
  FeList(FeList&& from) noexcept
    : FeList() {
    *this = ::std::move(from);
  }

  inline FeList& operator=(const FeList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeList& operator=(FeList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeList* internal_default_instance() {
    return reinterpret_cast<const FeList*>(
               &_FeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(FeList& a, FeList& b) {
    a.Swap(&b);
  }
  inline void Swap(FeList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FeList& from) {
    FeList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.FeList";
  }
  protected:
  explicit FeList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeFieldNumber = 1,
  };
  // repeated uint64 fe = 1;
  int fe_size() const;
  private:
  int _internal_fe_size() const;

  public:
  void clear_fe() ;
  ::uint64_t fe(int index) const;
  void set_fe(int index, ::uint64_t value);
  void add_fe(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& fe() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_fe();

  private:
  ::uint64_t _internal_fe(int index) const;
  void _internal_add_fe(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_fe() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_fe();

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.FeList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> fe_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _fe_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class SiblingList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.SiblingList) */ {
 public:
  inline SiblingList() : SiblingList(nullptr) {}
  ~SiblingList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SiblingList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SiblingList(const SiblingList& from);
  SiblingList(SiblingList&& from) noexcept
    : SiblingList() {
    *this = ::std::move(from);
  }

  inline SiblingList& operator=(const SiblingList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiblingList& operator=(SiblingList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SiblingList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SiblingList* internal_default_instance() {
    return reinterpret_cast<const SiblingList*>(
               &_SiblingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SiblingList& a, SiblingList& b) {
    a.Swap(&b);
  }
  inline void Swap(SiblingList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiblingList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SiblingList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SiblingList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SiblingList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SiblingList& from) {
    SiblingList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SiblingList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.SiblingList";
  }
  protected:
  explicit SiblingList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiblingFieldNumber = 1,
  };
  // repeated uint64 sibling = 1;
  int sibling_size() const;
  private:
  int _internal_sibling_size() const;

  public:
  void clear_sibling() ;
  ::uint64_t sibling(int index) const;
  void set_sibling(int index, ::uint64_t value);
  void add_sibling(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& sibling() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* mutable_sibling();

  private:
  ::uint64_t _internal_sibling(int index) const;
  void _internal_add_sibling(::uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& _internal_sibling() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* _internal_mutable_sibling();

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.SiblingList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t> sibling_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _sibling_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};// -------------------------------------------------------------------

class ResultCode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hashdb.v1.ResultCode) */ {
 public:
  inline ResultCode() : ResultCode(nullptr) {}
  ~ResultCode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResultCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultCode(const ResultCode& from);
  ResultCode(ResultCode&& from) noexcept
    : ResultCode() {
    *this = ::std::move(from);
  }

  inline ResultCode& operator=(const ResultCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultCode& operator=(ResultCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultCode* internal_default_instance() {
    return reinterpret_cast<const ResultCode*>(
               &_ResultCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResultCode& a, ResultCode& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultCode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultCode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultCode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResultCode& from) {
    ResultCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "hashdb.v1.ResultCode";
  }
  protected:
  explicit ResultCode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Code = ResultCode_Code;
  static constexpr Code CODE_UNSPECIFIED = ResultCode_Code_CODE_UNSPECIFIED;
  static constexpr Code CODE_SUCCESS = ResultCode_Code_CODE_SUCCESS;
  static constexpr Code CODE_DB_KEY_NOT_FOUND = ResultCode_Code_CODE_DB_KEY_NOT_FOUND;
  static constexpr Code CODE_DB_ERROR = ResultCode_Code_CODE_DB_ERROR;
  static constexpr Code CODE_INTERNAL_ERROR = ResultCode_Code_CODE_INTERNAL_ERROR;
  static constexpr Code CODE_SMT_INVALID_DATA_SIZE = ResultCode_Code_CODE_SMT_INVALID_DATA_SIZE;
  static inline bool Code_IsValid(int value) {
    return ResultCode_Code_IsValid(value);
  }
  static constexpr Code Code_MIN = ResultCode_Code_Code_MIN;
  static constexpr Code Code_MAX = ResultCode_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE = ResultCode_Code_Code_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Code_descriptor() {
    return ResultCode_Code_descriptor();
  }
  template <typename T>
  static inline const std::string& Code_Name(T value) {
    return ResultCode_Code_Name(value);
  }
  static inline bool Code_Parse(absl::string_view name, Code* value) {
    return ResultCode_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // .hashdb.v1.ResultCode.Code code = 1;
  void clear_code() ;
  ::hashdb::v1::ResultCode_Code code() const;
  void set_code(::hashdb::v1::ResultCode_Code value);

  private:
  ::hashdb::v1::ResultCode_Code _internal_code() const;
  void _internal_set_code(::hashdb::v1::ResultCode_Code value);

  public:
  // @@protoc_insertion_point(class_scope:hashdb.v1.ResultCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_hashdb_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  _impl_.v0_0_1_.ClearToEmpty();
}
inline const std::string& Version::v0_0_1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Version::set_v0_0_1(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.v0_0_1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() {
  std::string* _s = _internal_mutable_v0_0_1();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.Version.v0_0_1)
  return _s;
}
inline const std::string& Version::_internal_v0_0_1() const {
  return _impl_.v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  ;


  _impl_.v0_0_1_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  ;
  return _impl_.v0_0_1_.Mutable( GetArenaForAllocation());
}
inline std::string* Version::release_v0_0_1() {
  // @@protoc_insertion_point(field_release:hashdb.v1.Version.v0_0_1)
  return _impl_.v0_0_1_.Release();
}
inline void Version::set_allocated_v0_0_1(std::string* value) {
  _impl_.v0_0_1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.v0_0_1_.IsDefault()) {
          _impl_.v0_0_1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// SetRequest

// .hashdb.v1.Fea old_root = 1;
inline bool SetRequest::has_old_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_root_ != nullptr);
  return value;
}
inline void SetRequest::clear_old_root() {
  if (_impl_.old_root_ != nullptr) _impl_.old_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = _impl_.old_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.old_root)
  return _internal_old_root();
}
inline void SetRequest::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_root_);
  }
  _impl_.old_root_ = old_root;
  if (old_root) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.old_root)
}
inline ::hashdb::v1::Fea* SetRequest::release_old_root() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.old_root)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_old_root() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.old_root_ = p;
  }
  return _impl_.old_root_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_old_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_old_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.old_root)
  return _msg;
}
inline void SetRequest::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.old_root)
}

// .hashdb.v1.Fea key = 2;
inline bool SetRequest::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void SetRequest::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hashdb::v1::Fea& SetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.key)
  return _internal_key();
}
inline void SetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetRequest.key)
}
inline ::hashdb::v1::Fea* SetRequest::release_key() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.key)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* SetRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.key)
  return _msg;
}
inline void SetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.key)
}

// string value = 3;
inline void SetRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SetRequest::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.value)
}
inline std::string* SetRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetRequest.value)
  return _s;
}
inline const std::string& SetRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SetRequest::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SetRequest::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetRequest.value)
  return _impl_.value_.Release();
}
inline void SetRequest::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetRequest.value)
}

// bool persistent = 4;
inline void SetRequest::clear_persistent() {
  _impl_.persistent_ = false;
}
inline bool SetRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.persistent)
  return _internal_persistent();
}
inline void SetRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.persistent)
}
inline bool SetRequest::_internal_persistent() const {
  return _impl_.persistent_;
}
inline void SetRequest::_internal_set_persistent(bool value) {
  ;
  _impl_.persistent_ = value;
}

// bool details = 5;
inline void SetRequest::clear_details() {
  _impl_.details_ = false;
}
inline bool SetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.details)
  return _internal_details();
}
inline void SetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.details)
}
inline bool SetRequest::_internal_details() const {
  return _impl_.details_;
}
inline void SetRequest::_internal_set_details(bool value) {
  ;
  _impl_.details_ = value;
}

// bool get_db_read_log = 6;
inline void SetRequest::clear_get_db_read_log() {
  _impl_.get_db_read_log_ = false;
}
inline bool SetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void SetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetRequest.get_db_read_log)
}
inline bool SetRequest::_internal_get_db_read_log() const {
  return _impl_.get_db_read_log_;
}
inline void SetRequest::_internal_set_get_db_read_log(bool value) {
  ;
  _impl_.get_db_read_log_ = value;
}

// -------------------------------------------------------------------

// GetRequest

// .hashdb.v1.Fea root = 1;
inline bool GetRequest::has_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.root_ != nullptr);
  return value;
}
inline void GetRequest::clear_root() {
  if (_impl_.root_ != nullptr) _impl_.root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_root() const {
  const ::hashdb::v1::Fea* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.root)
  return _internal_root();
}
inline void GetRequest::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.root)
}
inline ::hashdb::v1::Fea* GetRequest::release_root() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.root)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_root() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.root)
  return _msg;
}
inline void GetRequest::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetRequest::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void GetRequest::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hashdb::v1::Fea& GetRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.key)
  return _internal_key();
}
inline void GetRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetRequest.key)
}
inline ::hashdb::v1::Fea* GetRequest::release_key() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetRequest.key)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* GetRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetRequest.key)
  return _msg;
}
inline void GetRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetRequest.key)
}

// bool details = 3;
inline void GetRequest::clear_details() {
  _impl_.details_ = false;
}
inline bool GetRequest::details() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.details)
  return _internal_details();
}
inline void GetRequest::set_details(bool value) {
  _internal_set_details(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.details)
}
inline bool GetRequest::_internal_details() const {
  return _impl_.details_;
}
inline void GetRequest::_internal_set_details(bool value) {
  ;
  _impl_.details_ = value;
}

// bool get_db_read_log = 4;
inline void GetRequest::clear_get_db_read_log() {
  _impl_.get_db_read_log_ = false;
}
inline bool GetRequest::get_db_read_log() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetRequest.get_db_read_log)
  return _internal_get_db_read_log();
}
inline void GetRequest::set_get_db_read_log(bool value) {
  _internal_set_get_db_read_log(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetRequest.get_db_read_log)
}
inline bool GetRequest::_internal_get_db_read_log() const {
  return _impl_.get_db_read_log_;
}
inline void GetRequest::_internal_set_get_db_read_log(bool value) {
  ;
  _impl_.get_db_read_log_ = value;
}

// -------------------------------------------------------------------

// SetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool SetProgramRequest::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void SetProgramRequest::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::Fea& SetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.key)
  return _internal_key();
}
inline void SetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramRequest.key)
}
inline ::hashdb::v1::Fea* SetProgramRequest::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetProgramRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* SetProgramRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.key)
  return _msg;
}
inline void SetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.key)
}

// bytes data = 2;
inline void SetProgramRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SetProgramRequest::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetProgramRequest::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.data)
}
inline std::string* SetProgramRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramRequest.data)
  return _s;
}
inline const std::string& SetProgramRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SetProgramRequest::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SetProgramRequest::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* SetProgramRequest::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramRequest.data)
  return _impl_.data_.Release();
}
inline void SetProgramRequest::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramRequest.data)
}

// bool persistent = 3;
inline void SetProgramRequest::clear_persistent() {
  _impl_.persistent_ = false;
}
inline bool SetProgramRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramRequest.persistent)
  return _internal_persistent();
}
inline void SetProgramRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetProgramRequest.persistent)
}
inline bool SetProgramRequest::_internal_persistent() const {
  return _impl_.persistent_;
}
inline void SetProgramRequest::_internal_set_persistent(bool value) {
  ;
  _impl_.persistent_ = value;
}

// -------------------------------------------------------------------

// GetProgramRequest

// .hashdb.v1.Fea key = 1;
inline bool GetProgramRequest::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void GetProgramRequest::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::Fea& GetProgramRequest::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetProgramRequest::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramRequest.key)
  return _internal_key();
}
inline void GetProgramRequest::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramRequest.key)
}
inline ::hashdb::v1::Fea* GetProgramRequest::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramRequest.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetProgramRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* GetProgramRequest::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramRequest.key)
  return _msg;
}
inline void GetProgramRequest::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramRequest.key)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadDBRequest

// map<string, .hashdb.v1.FeList> input_db = 1;
inline int LoadDBRequest::_internal_input_db_size() const {
  return _impl_.input_db_.size();
}
inline int LoadDBRequest::input_db_size() const {
  return _internal_input_db_size();
}
inline void LoadDBRequest::clear_input_db() {
  _impl_.input_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::_internal_input_db() const {
  return _impl_.input_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
LoadDBRequest::input_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_input_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::_internal_mutable_input_db() {
  return _impl_.input_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
LoadDBRequest::mutable_input_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadDBRequest.input_db)
  return _internal_mutable_input_db();
}

// bool persistent = 2;
inline void LoadDBRequest::clear_persistent() {
  _impl_.persistent_ = false;
}
inline bool LoadDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadDBRequest.persistent)
}
inline bool LoadDBRequest::_internal_persistent() const {
  return _impl_.persistent_;
}
inline void LoadDBRequest::_internal_set_persistent(bool value) {
  ;
  _impl_.persistent_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// LoadProgramDBRequest

// map<string, bytes> input_program_db = 1;
inline int LoadProgramDBRequest::_internal_input_program_db_size() const {
  return _impl_.input_program_db_.size();
}
inline int LoadProgramDBRequest::input_program_db_size() const {
  return _internal_input_program_db_size();
}
inline void LoadProgramDBRequest::clear_input_program_db() {
  _impl_.input_program_db_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::_internal_input_program_db() const {
  return _impl_.input_program_db_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
LoadProgramDBRequest::input_program_db() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_input_program_db();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::_internal_mutable_input_program_db() {
  return _impl_.input_program_db_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
LoadProgramDBRequest::mutable_input_program_db() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.LoadProgramDBRequest.input_program_db)
  return _internal_mutable_input_program_db();
}

// bool persistent = 2;
inline void LoadProgramDBRequest::clear_persistent() {
  _impl_.persistent_ = false;
}
inline bool LoadProgramDBRequest::persistent() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.LoadProgramDBRequest.persistent)
  return _internal_persistent();
}
inline void LoadProgramDBRequest::set_persistent(bool value) {
  _internal_set_persistent(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.LoadProgramDBRequest.persistent)
}
inline bool LoadProgramDBRequest::_internal_persistent() const {
  return _impl_.persistent_;
}
inline void LoadProgramDBRequest::_internal_set_persistent(bool value) {
  ;
  _impl_.persistent_ = value;
}

// -------------------------------------------------------------------

// GetFlushDataRequest

// uint64 flush_id = 1;
inline void GetFlushDataRequest::clear_flush_id() {
  _impl_.flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushDataRequest::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataRequest.flush_id)
  return _internal_flush_id();
}
inline void GetFlushDataRequest::set_flush_id(::uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataRequest.flush_id)
}
inline ::uint64_t GetFlushDataRequest::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline void GetFlushDataRequest::_internal_set_flush_id(::uint64_t value) {
  ;
  _impl_.flush_id_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetResponse

// .hashdb.v1.Fea old_root = 1;
inline bool SetResponse::has_old_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_root_ != nullptr);
  return value;
}
inline void SetResponse::clear_old_root() {
  if (_impl_.old_root_ != nullptr) _impl_.old_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_old_root() const {
  const ::hashdb::v1::Fea* p = _impl_.old_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::old_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_root)
  return _internal_old_root();
}
inline void SetResponse::unsafe_arena_set_allocated_old_root(
    ::hashdb::v1::Fea* old_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_root_);
  }
  _impl_.old_root_ = old_root;
  if (old_root) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.old_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_old_root() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_old_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_root)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.old_root_;
  _impl_.old_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_old_root() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.old_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.old_root_ = p;
  }
  return _impl_.old_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_old_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_old_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_root)
  return _msg;
}
inline void SetResponse::set_allocated_old_root(::hashdb::v1::Fea* old_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.old_root_;
  }
  if (old_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_root);
    if (message_arena != submessage_arena) {
      old_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.old_root_ = old_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_root)
}

// .hashdb.v1.Fea new_root = 2;
inline bool SetResponse::has_new_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new_root_ != nullptr);
  return value;
}
inline void SetResponse::clear_new_root() {
  if (_impl_.new_root_ != nullptr) _impl_.new_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_new_root() const {
  const ::hashdb::v1::Fea* p = _impl_.new_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::new_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_root)
  return _internal_new_root();
}
inline void SetResponse::unsafe_arena_set_allocated_new_root(
    ::hashdb::v1::Fea* new_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_root_);
  }
  _impl_.new_root_ = new_root;
  if (new_root) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.new_root)
}
inline ::hashdb::v1::Fea* SetResponse::release_new_root() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.new_root_;
  _impl_.new_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_new_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_root)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.new_root_;
  _impl_.new_root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_new_root() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.new_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.new_root_ = p;
  }
  return _impl_.new_root_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_new_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_new_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_root)
  return _msg;
}
inline void SetResponse::set_allocated_new_root(::hashdb::v1::Fea* new_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.new_root_;
  }
  if (new_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_root);
    if (message_arena != submessage_arena) {
      new_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.new_root_ = new_root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_root)
}

// .hashdb.v1.Fea key = 3;
inline bool SetResponse::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void SetResponse::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.key)
  return _internal_key();
}
inline void SetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.key)
}
inline ::hashdb::v1::Fea* SetResponse::release_key() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.key)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.key)
  return _msg;
}
inline void SetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 4;
inline int SetResponse::_internal_siblings_size() const {
  return _impl_.siblings_.size();
}
inline int SetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void SetResponse::clear_siblings() {
  _impl_.siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
SetResponse::_internal_siblings() const {
  return _impl_.siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
SetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
SetResponse::_internal_mutable_siblings() {
  return _impl_.siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
SetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 5;
inline bool SetResponse::has_ins_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ins_key_ != nullptr);
  return value;
}
inline void SetResponse::clear_ins_key() {
  if (_impl_.ins_key_ != nullptr) _impl_.ins_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::hashdb::v1::Fea& SetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = _impl_.ins_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& SetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_key)
  return _internal_ins_key();
}
inline void SetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ins_key_);
  }
  _impl_.ins_key_ = ins_key;
  if (ins_key) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.ins_key)
}
inline ::hashdb::v1::Fea* SetResponse::release_ins_key() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_key)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* SetResponse::_internal_mutable_ins_key() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.ins_key_ = p;
  }
  return _impl_.ins_key_;
}
inline ::hashdb::v1::Fea* SetResponse::mutable_ins_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_ins_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_key)
  return _msg;
}
inline void SetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_key)
}

// string ins_value = 6;
inline void SetResponse::clear_ins_value() {
  _impl_.ins_value_.ClearToEmpty();
}
inline const std::string& SetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.ins_value)
  return _internal_ins_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetResponse::set_ins_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ins_value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.ins_value)
}
inline std::string* SetResponse::mutable_ins_value() {
  std::string* _s = _internal_mutable_ins_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.ins_value)
  return _s;
}
inline const std::string& SetResponse::_internal_ins_value() const {
  return _impl_.ins_value_.Get();
}
inline void SetResponse::_internal_set_ins_value(const std::string& value) {
  ;


  _impl_.ins_value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_ins_value() {
  ;
  return _impl_.ins_value_.Mutable( GetArenaForAllocation());
}
inline std::string* SetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.ins_value)
  return _impl_.ins_value_.Release();
}
inline void SetResponse::set_allocated_ins_value(std::string* value) {
  _impl_.ins_value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ins_value_.IsDefault()) {
          _impl_.ins_value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.ins_value)
}

// bool is_old0 = 7;
inline void SetResponse::clear_is_old0() {
  _impl_.is_old0_ = false;
}
inline bool SetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.is_old0)
  return _internal_is_old0();
}
inline void SetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.is_old0)
}
inline bool SetResponse::_internal_is_old0() const {
  return _impl_.is_old0_;
}
inline void SetResponse::_internal_set_is_old0(bool value) {
  ;
  _impl_.is_old0_ = value;
}

// string old_value = 8;
inline void SetResponse::clear_old_value() {
  _impl_.old_value_.ClearToEmpty();
}
inline const std::string& SetResponse::old_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.old_value)
  return _internal_old_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetResponse::set_old_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.old_value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.old_value)
}
inline std::string* SetResponse::mutable_old_value() {
  std::string* _s = _internal_mutable_old_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.old_value)
  return _s;
}
inline const std::string& SetResponse::_internal_old_value() const {
  return _impl_.old_value_.Get();
}
inline void SetResponse::_internal_set_old_value(const std::string& value) {
  ;


  _impl_.old_value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_old_value() {
  ;
  return _impl_.old_value_.Mutable( GetArenaForAllocation());
}
inline std::string* SetResponse::release_old_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.old_value)
  return _impl_.old_value_.Release();
}
inline void SetResponse::set_allocated_old_value(std::string* value) {
  _impl_.old_value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.old_value_.IsDefault()) {
          _impl_.old_value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.old_value)
}

// string new_value = 9;
inline void SetResponse::clear_new_value() {
  _impl_.new_value_.ClearToEmpty();
}
inline const std::string& SetResponse::new_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.new_value)
  return _internal_new_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetResponse::set_new_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.new_value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.new_value)
}
inline std::string* SetResponse::mutable_new_value() {
  std::string* _s = _internal_mutable_new_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.new_value)
  return _s;
}
inline const std::string& SetResponse::_internal_new_value() const {
  return _impl_.new_value_.Get();
}
inline void SetResponse::_internal_set_new_value(const std::string& value) {
  ;


  _impl_.new_value_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_new_value() {
  ;
  return _impl_.new_value_.Mutable( GetArenaForAllocation());
}
inline std::string* SetResponse::release_new_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.new_value)
  return _impl_.new_value_.Release();
}
inline void SetResponse::set_allocated_new_value(std::string* value) {
  _impl_.new_value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_value_.IsDefault()) {
          _impl_.new_value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.new_value)
}

// string mode = 10;
inline void SetResponse::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& SetResponse::mode() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.mode)
  return _internal_mode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetResponse::set_mode(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.mode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.mode)
}
inline std::string* SetResponse::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.mode)
  return _s;
}
inline const std::string& SetResponse::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void SetResponse::_internal_set_mode(const std::string& value) {
  ;


  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* SetResponse::_internal_mutable_mode() {
  ;
  return _impl_.mode_.Mutable( GetArenaForAllocation());
}
inline std::string* SetResponse::release_mode() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.mode)
  return _impl_.mode_.Release();
}
inline void SetResponse::set_allocated_mode(std::string* value) {
  _impl_.mode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mode_.IsDefault()) {
          _impl_.mode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.mode)
}

// uint64 proof_hash_counter = 11;
inline void SetResponse::clear_proof_hash_counter() {
  _impl_.proof_hash_counter_ = ::uint64_t{0u};
}
inline ::uint64_t SetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void SetResponse::set_proof_hash_counter(::uint64_t value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SetResponse.proof_hash_counter)
}
inline ::uint64_t SetResponse::_internal_proof_hash_counter() const {
  return _impl_.proof_hash_counter_;
}
inline void SetResponse::_internal_set_proof_hash_counter(::uint64_t value) {
  ;
  _impl_.proof_hash_counter_ = value;
}

// map<string, .hashdb.v1.FeList> db_read_log = 12;
inline int SetResponse::_internal_db_read_log_size() const {
  return _impl_.db_read_log_.size();
}
inline int SetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void SetResponse::clear_db_read_log() {
  _impl_.db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::_internal_db_read_log() const {
  return _impl_.db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
SetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::_internal_mutable_db_read_log() {
  return _impl_.db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
SetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.SetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 13;
inline bool SetResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void SetResponse::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::hashdb::v1::ResultCode& SetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetResponse.result)
  return _internal_result();
}
inline void SetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetResponse.result)
}
inline ::hashdb::v1::ResultCode* SetResponse::release_result() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetResponse.result)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetResponse::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* SetResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetResponse.result)
  return _msg;
}
inline void SetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetResponse.result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetResponse

// .hashdb.v1.Fea root = 1;
inline bool GetResponse::has_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.root_ != nullptr);
  return value;
}
inline void GetResponse::clear_root() {
  if (_impl_.root_ != nullptr) _impl_.root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_root() const {
  const ::hashdb::v1::Fea* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.root)
  return _internal_root();
}
inline void GetResponse::unsafe_arena_set_allocated_root(
    ::hashdb::v1::Fea* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.root)
}
inline ::hashdb::v1::Fea* GetResponse::release_root() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.root)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::Fea* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_root() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_root() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.root)
  return _msg;
}
inline void GetResponse::set_allocated_root(::hashdb::v1::Fea* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.root)
}

// .hashdb.v1.Fea key = 2;
inline bool GetResponse::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void GetResponse::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_key() const {
  const ::hashdb::v1::Fea* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.key)
  return _internal_key();
}
inline void GetResponse::unsafe_arena_set_allocated_key(
    ::hashdb::v1::Fea* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.key)
}
inline ::hashdb::v1::Fea* GetResponse::release_key() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.key)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::hashdb::v1::Fea* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.key)
  return _msg;
}
inline void GetResponse::set_allocated_key(::hashdb::v1::Fea* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.key)
}

// map<uint64, .hashdb.v1.SiblingList> siblings = 3;
inline int GetResponse::_internal_siblings_size() const {
  return _impl_.siblings_.size();
}
inline int GetResponse::siblings_size() const {
  return _internal_siblings_size();
}
inline void GetResponse::clear_siblings() {
  _impl_.siblings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
GetResponse::_internal_siblings() const {
  return _impl_.siblings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >&
GetResponse::siblings() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.siblings)
  return _internal_siblings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
GetResponse::_internal_mutable_siblings() {
  return _impl_.siblings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::uint64_t, ::hashdb::v1::SiblingList >*
GetResponse::mutable_siblings() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.siblings)
  return _internal_mutable_siblings();
}

// .hashdb.v1.Fea ins_key = 4;
inline bool GetResponse::has_ins_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ins_key_ != nullptr);
  return value;
}
inline void GetResponse::clear_ins_key() {
  if (_impl_.ins_key_ != nullptr) _impl_.ins_key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::hashdb::v1::Fea& GetResponse::_internal_ins_key() const {
  const ::hashdb::v1::Fea* p = _impl_.ins_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::Fea&>(
      ::hashdb::v1::_Fea_default_instance_);
}
inline const ::hashdb::v1::Fea& GetResponse::ins_key() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_key)
  return _internal_ins_key();
}
inline void GetResponse::unsafe_arena_set_allocated_ins_key(
    ::hashdb::v1::Fea* ins_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ins_key_);
  }
  _impl_.ins_key_ = ins_key;
  if (ins_key) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.ins_key)
}
inline ::hashdb::v1::Fea* GetResponse::release_ins_key() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::unsafe_arena_release_ins_key() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_key)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::hashdb::v1::Fea* temp = _impl_.ins_key_;
  _impl_.ins_key_ = nullptr;
  return temp;
}
inline ::hashdb::v1::Fea* GetResponse::_internal_mutable_ins_key() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ins_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::Fea>(GetArenaForAllocation());
    _impl_.ins_key_ = p;
  }
  return _impl_.ins_key_;
}
inline ::hashdb::v1::Fea* GetResponse::mutable_ins_key() {
  ::hashdb::v1::Fea* _msg = _internal_mutable_ins_key();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_key)
  return _msg;
}
inline void GetResponse::set_allocated_ins_key(::hashdb::v1::Fea* ins_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ins_key_;
  }
  if (ins_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ins_key);
    if (message_arena != submessage_arena) {
      ins_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ins_key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ins_key_ = ins_key;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_key)
}

// string ins_value = 5;
inline void GetResponse::clear_ins_value() {
  _impl_.ins_value_.ClearToEmpty();
}
inline const std::string& GetResponse::ins_value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.ins_value)
  return _internal_ins_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponse::set_ins_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ins_value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.ins_value)
}
inline std::string* GetResponse::mutable_ins_value() {
  std::string* _s = _internal_mutable_ins_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.ins_value)
  return _s;
}
inline const std::string& GetResponse::_internal_ins_value() const {
  return _impl_.ins_value_.Get();
}
inline void GetResponse::_internal_set_ins_value(const std::string& value) {
  ;


  _impl_.ins_value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_ins_value() {
  ;
  return _impl_.ins_value_.Mutable( GetArenaForAllocation());
}
inline std::string* GetResponse::release_ins_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.ins_value)
  return _impl_.ins_value_.Release();
}
inline void GetResponse::set_allocated_ins_value(std::string* value) {
  _impl_.ins_value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ins_value_.IsDefault()) {
          _impl_.ins_value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.ins_value)
}

// bool is_old0 = 6;
inline void GetResponse::clear_is_old0() {
  _impl_.is_old0_ = false;
}
inline bool GetResponse::is_old0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.is_old0)
  return _internal_is_old0();
}
inline void GetResponse::set_is_old0(bool value) {
  _internal_set_is_old0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.is_old0)
}
inline bool GetResponse::_internal_is_old0() const {
  return _impl_.is_old0_;
}
inline void GetResponse::_internal_set_is_old0(bool value) {
  ;
  _impl_.is_old0_ = value;
}

// string value = 7;
inline void GetResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResponse::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.value)
}
inline std::string* GetResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.value)
  return _s;
}
inline const std::string& GetResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void GetResponse::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResponse::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.value)
  return _impl_.value_.Release();
}
inline void GetResponse::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.value)
}

// uint64 proof_hash_counter = 8;
inline void GetResponse::clear_proof_hash_counter() {
  _impl_.proof_hash_counter_ = ::uint64_t{0u};
}
inline ::uint64_t GetResponse::proof_hash_counter() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.proof_hash_counter)
  return _internal_proof_hash_counter();
}
inline void GetResponse::set_proof_hash_counter(::uint64_t value) {
  _internal_set_proof_hash_counter(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetResponse.proof_hash_counter)
}
inline ::uint64_t GetResponse::_internal_proof_hash_counter() const {
  return _impl_.proof_hash_counter_;
}
inline void GetResponse::_internal_set_proof_hash_counter(::uint64_t value) {
  ;
  _impl_.proof_hash_counter_ = value;
}

// map<string, .hashdb.v1.FeList> db_read_log = 9;
inline int GetResponse::_internal_db_read_log_size() const {
  return _impl_.db_read_log_.size();
}
inline int GetResponse::db_read_log_size() const {
  return _internal_db_read_log_size();
}
inline void GetResponse::clear_db_read_log() {
  _impl_.db_read_log_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::_internal_db_read_log() const {
  return _impl_.db_read_log_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >&
GetResponse::db_read_log() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_db_read_log();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::_internal_mutable_db_read_log() {
  return _impl_.db_read_log_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::hashdb::v1::FeList >*
GetResponse::mutable_db_read_log() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetResponse.db_read_log)
  return _internal_mutable_db_read_log();
}

// .hashdb.v1.ResultCode result = 10;
inline bool GetResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void GetResponse::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::hashdb::v1::ResultCode& GetResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetResponse.result)
  return _internal_result();
}
inline void GetResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetResponse.result)
}
inline ::hashdb::v1::ResultCode* GetResponse::release_result() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetResponse.result)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetResponse::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetResponse.result)
  return _msg;
}
inline void GetResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetResponse.result)
}

// -------------------------------------------------------------------

// SetProgramResponse

// .hashdb.v1.ResultCode result = 1;
inline bool SetProgramResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void SetProgramResponse::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& SetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SetProgramResponse.result)
  return _internal_result();
}
inline void SetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.SetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::release_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.SetProgramResponse.result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* SetProgramResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.SetProgramResponse.result)
  return _msg;
}
inline void SetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.SetProgramResponse.result)
}

// -------------------------------------------------------------------

// GetProgramResponse

// bytes data = 1;
inline void GetProgramResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& GetProgramResponse::data() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetProgramResponse::set_data(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetProgramResponse.data)
}
inline std::string* GetProgramResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.data)
  return _s;
}
inline const std::string& GetProgramResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void GetProgramResponse::_internal_set_data(const std::string& value) {
  ;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetProgramResponse::_internal_mutable_data() {
  ;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* GetProgramResponse::release_data() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.data)
  return _impl_.data_.Release();
}
inline void GetProgramResponse::set_allocated_data(std::string* value) {
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.data)
}

// .hashdb.v1.ResultCode result = 2;
inline bool GetProgramResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void GetProgramResponse::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetProgramResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetProgramResponse.result)
  return _internal_result();
}
inline void GetProgramResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetProgramResponse.result)
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::release_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetProgramResponse.result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetProgramResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetProgramResponse.result)
  return _msg;
}
inline void GetProgramResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetProgramResponse.result)
}

// -------------------------------------------------------------------

// FlushResponse

// uint64 flush_id = 1;
inline void FlushResponse::clear_flush_id() {
  _impl_.flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t FlushResponse::flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.flush_id)
  return _internal_flush_id();
}
inline void FlushResponse::set_flush_id(::uint64_t value) {
  _internal_set_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.flush_id)
}
inline ::uint64_t FlushResponse::_internal_flush_id() const {
  return _impl_.flush_id_;
}
inline void FlushResponse::_internal_set_flush_id(::uint64_t value) {
  ;
  _impl_.flush_id_ = value;
}

// uint64 stored_flush_id = 2;
inline void FlushResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t FlushResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void FlushResponse::set_stored_flush_id(::uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FlushResponse.stored_flush_id)
}
inline ::uint64_t FlushResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline void FlushResponse::_internal_set_stored_flush_id(::uint64_t value) {
  ;
  _impl_.stored_flush_id_ = value;
}

// .hashdb.v1.ResultCode result = 3;
inline bool FlushResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void FlushResponse::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::ResultCode& FlushResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& FlushResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FlushResponse.result)
  return _internal_result();
}
inline void FlushResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.FlushResponse.result)
}
inline ::hashdb::v1::ResultCode* FlushResponse::release_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.FlushResponse.result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* FlushResponse::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* FlushResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.FlushResponse.result)
  return _msg;
}
inline void FlushResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.FlushResponse.result)
}

// -------------------------------------------------------------------

// GetFlushStatusResponse

// uint64 stored_flush_id = 1;
inline void GetFlushStatusResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushStatusResponse::set_stored_flush_id(::uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.stored_flush_id)
}
inline ::uint64_t GetFlushStatusResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline void GetFlushStatusResponse::_internal_set_stored_flush_id(::uint64_t value) {
  ;
  _impl_.stored_flush_id_ = value;
}

// uint64 storing_flush_id = 2;
inline void GetFlushStatusResponse::clear_storing_flush_id() {
  _impl_.storing_flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::storing_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
  return _internal_storing_flush_id();
}
inline void GetFlushStatusResponse::set_storing_flush_id(::uint64_t value) {
  _internal_set_storing_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_flush_id)
}
inline ::uint64_t GetFlushStatusResponse::_internal_storing_flush_id() const {
  return _impl_.storing_flush_id_;
}
inline void GetFlushStatusResponse::_internal_set_storing_flush_id(::uint64_t value) {
  ;
  _impl_.storing_flush_id_ = value;
}

// uint64 last_flush_id = 3;
inline void GetFlushStatusResponse::clear_last_flush_id() {
  _impl_.last_flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::last_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.last_flush_id)
  return _internal_last_flush_id();
}
inline void GetFlushStatusResponse::set_last_flush_id(::uint64_t value) {
  _internal_set_last_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.last_flush_id)
}
inline ::uint64_t GetFlushStatusResponse::_internal_last_flush_id() const {
  return _impl_.last_flush_id_;
}
inline void GetFlushStatusResponse::_internal_set_last_flush_id(::uint64_t value) {
  ;
  _impl_.last_flush_id_ = value;
}

// uint64 pending_to_flush_nodes = 4;
inline void GetFlushStatusResponse::clear_pending_to_flush_nodes() {
  _impl_.pending_to_flush_nodes_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::pending_to_flush_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
  return _internal_pending_to_flush_nodes();
}
inline void GetFlushStatusResponse::set_pending_to_flush_nodes(::uint64_t value) {
  _internal_set_pending_to_flush_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_nodes)
}
inline ::uint64_t GetFlushStatusResponse::_internal_pending_to_flush_nodes() const {
  return _impl_.pending_to_flush_nodes_;
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_nodes(::uint64_t value) {
  ;
  _impl_.pending_to_flush_nodes_ = value;
}

// uint64 pending_to_flush_program = 5;
inline void GetFlushStatusResponse::clear_pending_to_flush_program() {
  _impl_.pending_to_flush_program_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::pending_to_flush_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
  return _internal_pending_to_flush_program();
}
inline void GetFlushStatusResponse::set_pending_to_flush_program(::uint64_t value) {
  _internal_set_pending_to_flush_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.pending_to_flush_program)
}
inline ::uint64_t GetFlushStatusResponse::_internal_pending_to_flush_program() const {
  return _impl_.pending_to_flush_program_;
}
inline void GetFlushStatusResponse::_internal_set_pending_to_flush_program(::uint64_t value) {
  ;
  _impl_.pending_to_flush_program_ = value;
}

// uint64 storing_nodes = 6;
inline void GetFlushStatusResponse::clear_storing_nodes() {
  _impl_.storing_nodes_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::storing_nodes() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_nodes)
  return _internal_storing_nodes();
}
inline void GetFlushStatusResponse::set_storing_nodes(::uint64_t value) {
  _internal_set_storing_nodes(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_nodes)
}
inline ::uint64_t GetFlushStatusResponse::_internal_storing_nodes() const {
  return _impl_.storing_nodes_;
}
inline void GetFlushStatusResponse::_internal_set_storing_nodes(::uint64_t value) {
  ;
  _impl_.storing_nodes_ = value;
}

// uint64 storing_program = 7;
inline void GetFlushStatusResponse::clear_storing_program() {
  _impl_.storing_program_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushStatusResponse::storing_program() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.storing_program)
  return _internal_storing_program();
}
inline void GetFlushStatusResponse::set_storing_program(::uint64_t value) {
  _internal_set_storing_program(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.storing_program)
}
inline ::uint64_t GetFlushStatusResponse::_internal_storing_program() const {
  return _impl_.storing_program_;
}
inline void GetFlushStatusResponse::_internal_set_storing_program(::uint64_t value) {
  ;
  _impl_.storing_program_ = value;
}

// string prover_id = 8;
inline void GetFlushStatusResponse::clear_prover_id() {
  _impl_.prover_id_.ClearToEmpty();
}
inline const std::string& GetFlushStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _internal_prover_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetFlushStatusResponse::set_prover_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.prover_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushStatusResponse.prover_id)
}
inline std::string* GetFlushStatusResponse::mutable_prover_id() {
  std::string* _s = _internal_mutable_prover_id();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _s;
}
inline const std::string& GetFlushStatusResponse::_internal_prover_id() const {
  return _impl_.prover_id_.Get();
}
inline void GetFlushStatusResponse::_internal_set_prover_id(const std::string& value) {
  ;


  _impl_.prover_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::_internal_mutable_prover_id() {
  ;
  return _impl_.prover_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetFlushStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushStatusResponse.prover_id)
  return _impl_.prover_id_.Release();
}
inline void GetFlushStatusResponse::set_allocated_prover_id(std::string* value) {
  _impl_.prover_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prover_id_.IsDefault()) {
          _impl_.prover_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushStatusResponse.prover_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetFlushDataResponse

// uint64 stored_flush_id = 1;
inline void GetFlushDataResponse::clear_stored_flush_id() {
  _impl_.stored_flush_id_ = ::uint64_t{0u};
}
inline ::uint64_t GetFlushDataResponse::stored_flush_id() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.stored_flush_id)
  return _internal_stored_flush_id();
}
inline void GetFlushDataResponse::set_stored_flush_id(::uint64_t value) {
  _internal_set_stored_flush_id(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.stored_flush_id)
}
inline ::uint64_t GetFlushDataResponse::_internal_stored_flush_id() const {
  return _impl_.stored_flush_id_;
}
inline void GetFlushDataResponse::_internal_set_stored_flush_id(::uint64_t value) {
  ;
  _impl_.stored_flush_id_ = value;
}

// map<string, string> nodes = 2;
inline int GetFlushDataResponse::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GetFlushDataResponse::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetFlushDataResponse::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_nodes() const {
  return _impl_.nodes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::nodes() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_nodes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_nodes() {
  return _impl_.nodes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.nodes)
  return _internal_mutable_nodes();
}

// map<string, string> program = 3;
inline int GetFlushDataResponse::_internal_program_size() const {
  return _impl_.program_.size();
}
inline int GetFlushDataResponse::program_size() const {
  return _internal_program_size();
}
inline void GetFlushDataResponse::clear_program() {
  _impl_.program_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::_internal_program() const {
  return _impl_.program_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetFlushDataResponse::program() const {
  // @@protoc_insertion_point(field_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_program();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::_internal_mutable_program() {
  return _impl_.program_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetFlushDataResponse::mutable_program() {
  // @@protoc_insertion_point(field_mutable_map:hashdb.v1.GetFlushDataResponse.program)
  return _internal_mutable_program();
}

// string nodes_state_root = 4;
inline void GetFlushDataResponse::clear_nodes_state_root() {
  _impl_.nodes_state_root_.ClearToEmpty();
}
inline const std::string& GetFlushDataResponse::nodes_state_root() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _internal_nodes_state_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetFlushDataResponse::set_nodes_state_root(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.nodes_state_root_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}
inline std::string* GetFlushDataResponse::mutable_nodes_state_root() {
  std::string* _s = _internal_mutable_nodes_state_root();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _s;
}
inline const std::string& GetFlushDataResponse::_internal_nodes_state_root() const {
  return _impl_.nodes_state_root_.Get();
}
inline void GetFlushDataResponse::_internal_set_nodes_state_root(const std::string& value) {
  ;


  _impl_.nodes_state_root_.Set(value, GetArenaForAllocation());
}
inline std::string* GetFlushDataResponse::_internal_mutable_nodes_state_root() {
  ;
  return _impl_.nodes_state_root_.Mutable( GetArenaForAllocation());
}
inline std::string* GetFlushDataResponse::release_nodes_state_root() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.nodes_state_root)
  return _impl_.nodes_state_root_.Release();
}
inline void GetFlushDataResponse::set_allocated_nodes_state_root(std::string* value) {
  _impl_.nodes_state_root_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodes_state_root_.IsDefault()) {
          _impl_.nodes_state_root_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.nodes_state_root)
}

// .hashdb.v1.ResultCode result = 5;
inline bool GetFlushDataResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void GetFlushDataResponse::clear_result() {
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::_internal_result() const {
  const ::hashdb::v1::ResultCode* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::hashdb::v1::ResultCode&>(
      ::hashdb::v1::_ResultCode_default_instance_);
}
inline const ::hashdb::v1::ResultCode& GetFlushDataResponse::result() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.GetFlushDataResponse.result)
  return _internal_result();
}
inline void GetFlushDataResponse::unsafe_arena_set_allocated_result(
    ::hashdb::v1::ResultCode* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::release_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:hashdb.v1.GetFlushDataResponse.result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::hashdb::v1::ResultCode* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::_internal_mutable_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hashdb::v1::ResultCode>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::hashdb::v1::ResultCode* GetFlushDataResponse::mutable_result() {
  ::hashdb::v1::ResultCode* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:hashdb.v1.GetFlushDataResponse.result)
  return _msg;
}
inline void GetFlushDataResponse::set_allocated_result(::hashdb::v1::ResultCode* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hashdb.v1.GetFlushDataResponse.result)
}

// -------------------------------------------------------------------

// Fea

// uint64 fe0 = 1;
inline void Fea::clear_fe0() {
  _impl_.fe0_ = ::uint64_t{0u};
}
inline ::uint64_t Fea::fe0() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe0)
  return _internal_fe0();
}
inline void Fea::set_fe0(::uint64_t value) {
  _internal_set_fe0(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe0)
}
inline ::uint64_t Fea::_internal_fe0() const {
  return _impl_.fe0_;
}
inline void Fea::_internal_set_fe0(::uint64_t value) {
  ;
  _impl_.fe0_ = value;
}

// uint64 fe1 = 2;
inline void Fea::clear_fe1() {
  _impl_.fe1_ = ::uint64_t{0u};
}
inline ::uint64_t Fea::fe1() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe1)
  return _internal_fe1();
}
inline void Fea::set_fe1(::uint64_t value) {
  _internal_set_fe1(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe1)
}
inline ::uint64_t Fea::_internal_fe1() const {
  return _impl_.fe1_;
}
inline void Fea::_internal_set_fe1(::uint64_t value) {
  ;
  _impl_.fe1_ = value;
}

// uint64 fe2 = 3;
inline void Fea::clear_fe2() {
  _impl_.fe2_ = ::uint64_t{0u};
}
inline ::uint64_t Fea::fe2() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe2)
  return _internal_fe2();
}
inline void Fea::set_fe2(::uint64_t value) {
  _internal_set_fe2(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe2)
}
inline ::uint64_t Fea::_internal_fe2() const {
  return _impl_.fe2_;
}
inline void Fea::_internal_set_fe2(::uint64_t value) {
  ;
  _impl_.fe2_ = value;
}

// uint64 fe3 = 4;
inline void Fea::clear_fe3() {
  _impl_.fe3_ = ::uint64_t{0u};
}
inline ::uint64_t Fea::fe3() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.Fea.fe3)
  return _internal_fe3();
}
inline void Fea::set_fe3(::uint64_t value) {
  _internal_set_fe3(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.Fea.fe3)
}
inline ::uint64_t Fea::_internal_fe3() const {
  return _impl_.fe3_;
}
inline void Fea::_internal_set_fe3(::uint64_t value) {
  ;
  _impl_.fe3_ = value;
}

// -------------------------------------------------------------------

// FeList

// repeated uint64 fe = 1;
inline int FeList::_internal_fe_size() const {
  return _impl_.fe_.size();
}
inline int FeList::fe_size() const {
  return _internal_fe_size();
}
inline void FeList::clear_fe() {
  _internal_mutable_fe()->Clear();
}
inline ::uint64_t FeList::fe(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.FeList.fe)
  return _internal_fe(index);
}
inline void FeList::set_fe(int index, ::uint64_t value) {
  _internal_mutable_fe()->Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.FeList.fe)
}
inline void FeList::add_fe(::uint64_t value) {
  _internal_add_fe(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.FeList.fe)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& FeList::fe() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.FeList.fe)
  return _internal_fe();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* FeList::mutable_fe() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.FeList.fe)
  return _internal_mutable_fe();
}

inline ::uint64_t FeList::_internal_fe(int index) const {
  return _internal_fe().Get(index);
}
inline void FeList::_internal_add_fe(::uint64_t value) {
  _internal_mutable_fe()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& FeList::_internal_fe() const {
  return _impl_.fe_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* FeList::_internal_mutable_fe() {
  return &_impl_.fe_;
}

// -------------------------------------------------------------------

// SiblingList

// repeated uint64 sibling = 1;
inline int SiblingList::_internal_sibling_size() const {
  return _impl_.sibling_.size();
}
inline int SiblingList::sibling_size() const {
  return _internal_sibling_size();
}
inline void SiblingList::clear_sibling() {
  _internal_mutable_sibling()->Clear();
}
inline ::uint64_t SiblingList::sibling(int index) const {
  // @@protoc_insertion_point(field_get:hashdb.v1.SiblingList.sibling)
  return _internal_sibling(index);
}
inline void SiblingList::set_sibling(int index, ::uint64_t value) {
  _internal_mutable_sibling()->Set(index, value);
  // @@protoc_insertion_point(field_set:hashdb.v1.SiblingList.sibling)
}
inline void SiblingList::add_sibling(::uint64_t value) {
  _internal_add_sibling(value);
  // @@protoc_insertion_point(field_add:hashdb.v1.SiblingList.sibling)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& SiblingList::sibling() const {
  // @@protoc_insertion_point(field_list:hashdb.v1.SiblingList.sibling)
  return _internal_sibling();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* SiblingList::mutable_sibling() {
  // @@protoc_insertion_point(field_mutable_list:hashdb.v1.SiblingList.sibling)
  return _internal_mutable_sibling();
}

inline ::uint64_t SiblingList::_internal_sibling(int index) const {
  return _internal_sibling().Get(index);
}
inline void SiblingList::_internal_add_sibling(::uint64_t value) {
  _internal_mutable_sibling()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>& SiblingList::_internal_sibling() const {
  return _impl_.sibling_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::uint64_t>* SiblingList::_internal_mutable_sibling() {
  return &_impl_.sibling_;
}

// -------------------------------------------------------------------

// ResultCode

// .hashdb.v1.ResultCode.Code code = 1;
inline void ResultCode::clear_code() {
  _impl_.code_ = 0;
}
inline ::hashdb::v1::ResultCode_Code ResultCode::code() const {
  // @@protoc_insertion_point(field_get:hashdb.v1.ResultCode.code)
  return _internal_code();
}
inline void ResultCode::set_code(::hashdb::v1::ResultCode_Code value) {
   _internal_set_code(value);
  // @@protoc_insertion_point(field_set:hashdb.v1.ResultCode.code)
}
inline ::hashdb::v1::ResultCode_Code ResultCode::_internal_code() const {
  return static_cast<::hashdb::v1::ResultCode_Code>(_impl_.code_);
}
inline void ResultCode::_internal_set_code(::hashdb::v1::ResultCode_Code value) {
  ;
  _impl_.code_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace hashdb


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::hashdb::v1::ResultCode_Code> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::hashdb::v1::ResultCode_Code>() {
  return ::hashdb::v1::ResultCode_Code_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_hashdb_2eproto_2epb_2eh

#include "state_manager_64.hpp"
#include "zkassert.hpp"
#include "zklog.hpp"
#include "scalar.hpp"
#include "timer.hpp"
#include "persistence.hpp"
#include "definitions.hpp"
#include "zkglobals.hpp"

// Singleton definition
StateManager64 stateManager64;

#define LOG_STATE_MANAGER
#define LOG_STATE_MANAGER_READ
#define LOG_STATE_MANAGER_WRITE
#define LOG_STATE_MANAGER_WRITE_PROGRAM

zkresult StateManager64::setStateRoot (const string &batchUUID, uint64_t block, uint64_t tx, const string &_stateRoot, bool bIsOldStateRoot, const Persistence persistence)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    zkresult zkr;

    // Normalize state root format
    string stateRoot = NormalizeToNFormat(_stateRoot, 64);
    stateRoot = stringToLower(stateRoot);

    // Check persistence range
    if (persistence >= PERSISTENCE_SIZE)
    {
        zklog.error("StateManager64::setStateRoot() invalid persistence batchUUID=" + batchUUID + " tx=" + to_string(tx) + " stateRoot=" + stateRoot + " bIsOldStateRoot=" + to_string(bIsOldStateRoot) + " persistence=" + persistence2string(persistence));
        return ZKR_STATE_MANAGER;
    }

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::setStateRoot() batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " stateRoot=" + stateRoot + " bIsOldStateRoot=" + to_string(bIsOldStateRoot) + " persistence=" + persistence2string(persistence));
#endif

    Lock();

    unordered_map<string, BatchState64>::iterator it;

    // Find batch state for this uuid, or create it if it does not exist
    it = state.find(batchUUID);
    if (it == state.end())
    {
        if (!bIsOldStateRoot)
        {
            zklog.error("StateManager64::setStateRoot() called with bIsOldStateRoot=false, but batchUUID=" + batchUUID + " does not previously exist");
            Unlock();
            return ZKR_STATE_MANAGER;
        }
        BatchState64 batchState;
        state[batchUUID] = batchState;
        stateOrder.emplace_back(batchUUID);
        it = state.find(batchUUID);
        zkassert(it != state.end());
    }
    BatchState64 &batchState = it->second;

    // The first time we set a non-temporary old state root, assign it to the batch old state root
    if ( batchState.oldStateRoot.empty() &&
         ((persistence == PERSISTENCE_DATABASE) || (persistence == PERSISTENCE_CACHE)) &&
         bIsOldStateRoot )
    {
        batchState.oldStateRoot = stateRoot;
    }

    // Set the current state root
    batchState.currentStateRoot = stateRoot;

    // Check block range, and create any previous block state if missing
    // This is required for forks < 7 where block start/finish events are not generated by the ROM,
    // and onFinishTx() is not generated for tx=0 because it is a virtual TX to contain SMT activity previous to the first real TX
    if (block >= batchState.blockState.size())
    {
        BlockState64 emptyBlockState;
        while (block >= batchState.blockState.size())
        {
            batchState.blockState.emplace_back(emptyBlockState);
        }
        batchState.currentBlock = batchState.blockState.size() - 1;
    }

    // Get a reference to the block state
    BlockState64 &blockState = batchState.blockState[block];

    // The first time we set a non-temporary old state root, assign it to the block old state root
    if ( blockState.oldStateRoot.empty() &&
         ((persistence == PERSISTENCE_DATABASE) || (persistence == PERSISTENCE_CACHE)) &&
         bIsOldStateRoot )
    {
        blockState.oldStateRoot = stateRoot;
    }

    // If this is a new state root, update the current state root of the block
    if ( ((persistence == PERSISTENCE_DATABASE) || (persistence == PERSISTENCE_CACHE)) &&
         !bIsOldStateRoot )
    {
        blockState.currentStateRoot = stateRoot;
    }


    // Create tx states, if needed
    if (tx >= blockState.txState.size())
    {
        // If this is the first state of a new tx, check that it is the old state root
        if (!bIsOldStateRoot)
        {
            zklog.error("StateManager64::setStateRoot() called with bIsOldStateRoot=false, but tx=" + to_string(tx) + " does not previously exist");
            Unlock();
            return ZKR_STATE_MANAGER;
        }

        // Calculate the number of tx slots to create
        uint64_t txsToCreate = tx - blockState.txState.size() + 1;

        // Create TX state to insert
        TxState64 txState;
        
        // Insert TX state
        for (uint64_t i=0; i<txsToCreate; i++)
        {
            blockState.txState.emplace_back(txState);
        }

        // Set current TX
        blockState.currentTx = tx;
    }

    // Get a reference to the tx state
    TxState64 &txState = blockState.txState[tx];

    // Get the current sub-state list size
    uint64_t currentSubStateSize = txState.persistence[persistence].subState.size();
    
    // In case it is an old state root, we need to create a new sub-state, and check that everything makes sense
    if (bIsOldStateRoot)
    {
        // If this is the first sub-state of the tx state, record the tx old state root
        if ( currentSubStateSize == 0)
        {
            // Check current sub-state
            if (txState.persistence[persistence].currentSubState != 0)
            {
                zklog.error("StateManager64::setStateRoot() currentSubState=" + to_string(txState.persistence[persistence].currentSubState) + "!=0 batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " stateRoot=" + stateRoot + " bIsOldStateRoot=" + to_string(bIsOldStateRoot) + " persistence=" + persistence2string(persistence));
                Unlock();
                return ZKR_STATE_MANAGER;
            }

            // Record the old state root
            txState.persistence[persistence].oldStateRoot = stateRoot;
        }

        // If it is not the first sub-state, it must have been called with the previous new state root
        else
        {
            // Check current sub-state
            if (txState.persistence[persistence].currentSubState >= currentSubStateSize)
            {
                zklog.error("StateManager64::setStateRoot() currentSubState=" + to_string(txState.persistence[persistence].currentSubState) + " > currentSubStateSize=" + to_string(currentSubStateSize) + " batchUUID=" + batchUUID + " block=" + to_string(block) +  " tx=" + to_string(tx) + " stateRoot=" + stateRoot + " bIsOldStateRoot=" + to_string(bIsOldStateRoot) + " persistence=" + persistence2string(persistence));
                Unlock();
                return ZKR_STATE_MANAGER;
            }

            // Check that new state root is empty
            if (txState.persistence[persistence].subState[currentSubStateSize - 1].newStateRoot.empty())
            {
                zklog.error("StateManager64::setStateRoot() oldStateRoot found previous newStateRoot empty");
                Unlock();
                return ZKR_STATE_MANAGER;
            }
        }

        // Create TX sub-state
        TxSubState64 txSubState;
        txSubState.oldStateRoot = stateRoot;
        txSubState.previousSubState = txState.persistence[persistence].currentSubState;

        // Find the previous state, if it exists
        for (uint64_t i = 0; i < currentSubStateSize; i++)
        {
            if (txState.persistence[persistence].subState[i].newStateRoot == stateRoot)
            {
                // Delete the keys of the rest of sub states
                for (uint64_t j = i+1; j < currentSubStateSize; j++)
                {
                    unordered_map<string, mpz_class> &dbWrite = txState.persistence[persistence].subState[j].dbWrite;
                    unordered_map<string, mpz_class>::const_iterator it;
                    for (it = dbWrite.begin(); it != dbWrite.end(); it++)
                    {
                        Goldilocks::Element key_[4];
                        string2fea(fr, it->first, key_);
                        zkr = batchState.keyValueTree.extract(key_, it->second);
                        if (zkr != ZKR_SUCCESS)
                        {
                            zklog.error("StateManager64::setStateRoot() failed calling batchState.keyValueTree.extract()");
                            Unlock();
                            return ZKR_STATE_MANAGER;
                        }
                    }
                }
            }
        }

        // Insert it
        txState.persistence[persistence].subState.emplace_back(txSubState);

        // Record the current state
        txState.persistence[persistence].currentSubState = txState.persistence[persistence].subState.size() - 1;
    }

    // If it is a new state root, we need to complete the current sub-state
    else
    {
        if (txState.persistence[persistence].currentSubState >= currentSubStateSize)
        {
            zklog.error("StateManager64::setStateRoot() currentSubState=" + to_string(txState.persistence[persistence].currentSubState) + " > currentSubStateSize=" + to_string(currentSubStateSize) + " batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " stateRoot=" + stateRoot + " bIsOldStateRoot=" + to_string(bIsOldStateRoot) + " persistence=" + persistence2string(persistence));
            Unlock();
            return ZKR_STATE_MANAGER;
        }

        // Check that the new state root is empty
        if (txState.persistence[persistence].subState[txState.persistence[persistence].currentSubState].newStateRoot.size() != 0)
        {
            zklog.error("StateManager64::setStateRoot() found nesStateRoot busy");
            Unlock();
            return ZKR_STATE_MANAGER;
        }

        // Record the new state root in the tx sub-state, and in the tx state
        txState.persistence[persistence].subState[txState.persistence[persistence].currentSubState].newStateRoot = stateRoot;
        txState.persistence[persistence].newStateRoot = stateRoot;
    }

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("setStateRoot", TimeDiff(t));
#endif

    Unlock();

    return ZKR_SUCCESS;
}

zkresult StateManager64::write (const string &batchUUID, uint64_t block, uint64_t tx, const string &key, const mpz_class &value, const Persistence persistence, uint64_t &level)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

#ifdef LOG_STATE_MANAGER_WRITE
    zklog.info("StateManager64::write() batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " key=" + key + " value=" + value.get_str(16) + " persistence=" + persistence2string(persistence));
#endif

    // Check persistence range
    if (persistence >= PERSISTENCE_SIZE)
    {
        zklog.error("StateManager64::write() wrong persistence batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " key=" + key + " persistence=" + persistence2string(persistence));
        return ZKR_STATE_MANAGER;
    }

    Lock();

    // Find batch state for this uuid
    unordered_map<string, BatchState64>::iterator it;
    it = state.find(batchUUID);
    if (it == state.end())
    {
        zklog.error("StateManager64::write() found no batch state for batch UUID=" + batchUUID);
        Unlock();
        return ZKR_STATE_MANAGER;
    }
    BatchState64 &batchState = it->second;

    // Check block range
    if (block >= batchState.blockState.size())
    {
        zklog.error("StateManage64r::write() got block=" + to_string(block) + " bigger than blockState size=" + to_string(it->second.blockState.size()));
        Unlock();
        return ZKR_STATE_MANAGER;
    }
    BlockState64 &blockState = batchState.blockState[block];

    // Check tx range
    if (tx > blockState.txState.size())
    {
        zklog.error("StateManager64::write() got tx=" + to_string(tx) + " bigger than txState size=" + to_string(blockState.txState.size()));
        Unlock();
        return ZKR_STATE_MANAGER;
    }

    // Create TxState, if not existing
    if (tx == blockState.txState.size())
    {
        TxState64 aux;
        aux.persistence[persistence].oldStateRoot = it->second.currentStateRoot;
        blockState.txState.emplace_back(aux);
    }
    TxState64 &txState = blockState.txState[tx];

    // Create TxSubState, if not existing
    if (txState.persistence[persistence].subState.size() == 0)
    {
        TxSubState64 subState;
        subState.previousSubState = 0;
        subState.oldStateRoot = batchState.currentStateRoot;
        txState.persistence[persistence].subState.emplace_back(subState);
        txState.persistence[persistence].currentSubState = 0;
    }

    // Add to sub-state
    txState.persistence[persistence].subState[txState.persistence[persistence].currentSubState].dbWrite[key] = value;
    
    // Add to common write pool to speed up read
    //batchState.dbWrite[key] = value;
    Goldilocks::Element key_[4];
    string2fea(fr, key, key_);
    batchState.keyValueTree.write(key_, value, level);

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("write", TimeDiff(t));
#endif

    Unlock();

    return ZKR_SUCCESS;
}

zkresult StateManager64::read (const string &batchUUID, const string &key, mpz_class &value, uint64_t &level, DatabaseMap *dbReadLog)
{
    struct timeval t;
    gettimeofday(&t, NULL);

    Lock();

    // Find batch state for this uuid
    unordered_map<string, BatchState64>::iterator it;
    it = state.find(batchUUID);
    if (it == state.end())
    {
        //zklog.error("StateManager64::read() found no batch state for batch UUID=" + batchUUID);
        Unlock();
        return ZKR_DB_KEY_NOT_FOUND;
    }
    BatchState64 &batchState = it->second;

    // Search in the common write list
    //unordered_map<string, mpz_class>::iterator dbIt;
    //dbIt = batchState.dbWrite.find(key);
    //if (dbIt != batchState.dbWrite.end())

    // Search in the common key-value tree
    Goldilocks::Element key_[4];
    string2fea(fr, key, key_);
    zkresult zkr = batchState.keyValueTree.read(key_, value, level);
    if (zkr == ZKR_SUCCESS)
    {                        
        // Add to the read log
        if (dbReadLog != NULL) dbReadLog->add(key, value.get_str(16), true, TimeDiff(t));

#ifdef LOG_STATE_MANAGER_READ
        zklog.info("StateManager64::read() batchUUID=" + batchUUID + " key=" + key);
#endif

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        batchState.timeMetricStorage.add("read success", TimeDiff(t));
#endif
        Unlock();

        return ZKR_SUCCESS;
    }

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("read not found", TimeDiff(t));
#endif

    Unlock();

    return ZKR_DB_KEY_NOT_FOUND;
}

bool IsInvalid(TxSubState64 &txSubState)
{
    return !txSubState.bValid;
}

zkresult StateManager64::finishTx (const string &batchUUID, const string &_stateRoot, const Persistence persistence)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    // Normalize state root format
    string stateRoot = NormalizeToNFormat(_stateRoot, 64);
    stateRoot = stringToLower(stateRoot);

    // Check persistence range
    if (persistence >= PERSISTENCE_SIZE)
    {
        zklog.error("StateManager64::finishTx() invalid persistence batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        return ZKR_STATE_MANAGER;
    }

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::finishTx() batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
#endif

    Lock();

    unordered_map<string, BatchState64>::iterator it;

    // Find batch state for this uuid
    it = state.find(batchUUID);
    if (it == state.end())
    {
        zklog.warning("StateManager64::finishTx() found no batch state for batch UUID=" + batchUUID + "; normal if no SMT activity happened");
 
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        //batchState.timeMetricStorage.add("finishTx UUID not found", TimeDiff(t));
        //batchState.timeMetricStorage.print("State Manager calls");
#endif
        Unlock();
        return ZKR_SUCCESS;
    }
    BatchState64 &batchState = it->second;

    // Check currentBlock range
    if (batchState.currentBlock >= batchState.blockState.size())
    {
        zklog.error("StateManager::finishTx() found batchState.currentBlock=" + to_string(batchState.currentBlock) + " >= batchState.blockState.size=" + to_string(batchState.blockState.size()) + " batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        Unlock();
        return ZKR_STATE_MANAGER;
    }
    BlockState64 &blockState = batchState.blockState[batchState.currentBlock];

    // Check currentTx range
    if (blockState.currentTx >= blockState.txState.size())
    {
        zklog.error("StateManager::finishTx() found blockState.currentTx=" + to_string(blockState.currentTx) + " >= blockState.txState.size=" + to_string(blockState.txState.size()) + " batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        Unlock();
        return ZKR_STATE_MANAGER;
    }

    // Get a reference to the tx state
    TxState64 &txState = blockState.txState[blockState.currentTx];
    TxPersistenceState64 &txPersistenceState = txState.persistence[persistence];

    if (txPersistenceState.newStateRoot == stateRoot)
    {
        // This is the expected case
    }
    else if (txPersistenceState.oldStateRoot == stateRoot)
    {
        if (config.stateManagerPurge)
        {
            // The TX ended up with the same state root as the beginning, so we can delete all data
            txPersistenceState.subState.clear();
            txPersistenceState.newStateRoot = stateRoot;
            txPersistenceState.currentSubState = 0;
        }
    }
    else
    {
        if (config.stateManagerPurge)
        {
            // Search for the point at which we reach this state, and delete the rest
            bool bFound = false;
            uint64_t i = 0;
            uint64_t subStateSize = txPersistenceState.subState.size();
            for (i = 0; i < subStateSize; i++)
            {
                if (!bFound && txPersistenceState.subState[i].oldStateRoot == stateRoot)
                {
                    bFound = true;
                    break;
                }
            }
            if (bFound)
            {
                txPersistenceState.newStateRoot = stateRoot;
                txPersistenceState.currentSubState = (i == 0) ? 0 : i - 1;
                for (; i < subStateSize; i++)
                {
                    txPersistenceState.subState.pop_back();
                }
            }
        }
    }
    
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("finishTx", TimeDiff(t));
#endif

    Unlock();

    return ZKR_SUCCESS;
}

zkresult StateManager64::startBlock (const string &batchUUID, const string &_stateRoot, const Persistence persistence)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    // Normalize state root format
    string stateRoot = NormalizeToNFormat(_stateRoot, 64);
    stateRoot = stringToLower(stateRoot);

    // Check persistence range
    if (persistence >= PERSISTENCE_SIZE)
    {
        zklog.error("StateManager64::startBlock() invalid persistence batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        return ZKR_STATE_MANAGER;
    }

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::startBlock() batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
#endif

    Lock();

    unordered_map<string, BatchState64>::iterator it;

    // Find batch state for this uuid
    it = state.find(batchUUID);
    if (it == state.end())
    {
        BatchState64 batchState;
        state[batchUUID] = batchState;
        stateOrder.emplace_back(batchUUID);
        it = state.find(batchUUID);
        zkassert(it != state.end());
    }
    BatchState64 &batchState = it->second;

    // Check currentBlock range
    if (!batchState.blockState.empty() && (batchState.currentBlock >= batchState.blockState.size()))
    {
        zklog.error("StateManager64::startBlock() found batchState.currentBlock=" + to_string(batchState.currentBlock) + " >= batchState.blockState.size=" + to_string(batchState.blockState.size()) + " batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        Unlock();
        return ZKR_STATE_MANAGER;
    }

    // Create an empty block state to insert
    BlockState64 blockState;
    blockState.oldStateRoot = stateRoot;
    batchState.blockState.emplace_back(blockState);

    // Set current block
    batchState.currentBlock = batchState.blockState.size() - 1;
    
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("startBlock", TimeDiff(t));
#endif

    Unlock();

    return ZKR_SUCCESS;
}

zkresult StateManager64::finishBlock (const string &batchUUID, const string &_stateRoot, const Persistence persistence)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    // Normalize state root format
    string stateRoot = NormalizeToNFormat(_stateRoot, 64);
    stateRoot = stringToLower(stateRoot);

    // Check persistence range
    if (persistence >= PERSISTENCE_SIZE)
    {
        zklog.error("StateManager64::finishBlock() invalid persistence batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        return ZKR_STATE_MANAGER;
    }

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::finishBlock() batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
#endif

    Lock();

    unordered_map<string, BatchState64>::iterator it;

    // Find batch state for this uuid
    it = state.find(batchUUID);
    if (it == state.end())
    {
        zklog.warning("StateManager64::finishBlock() found no batch state for batch UUID=" + batchUUID + "; normal if no SMT activity happened");
 
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        //batchState.timeMetricStorage.add("finishBlock UUID not found", TimeDiff(t));
        //batchState.timeMetricStorage.print("State Manager calls");
#endif
        Unlock();
        return ZKR_SUCCESS;
    }
    BatchState64 &batchState = it->second;

    // Check currentBlock range
    if (batchState.currentBlock >= batchState.blockState.size())
    {
        zklog.error("StateManager64::finishBlock() found batchState.currentBlock=" + to_string(batchState.currentBlock) + " >= batchState.blockState.size=" + to_string(batchState.blockState.size()) + " batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        Unlock();
        return ZKR_STATE_MANAGER;
    }
    BlockState64 &blockState = batchState.blockState[batchState.currentBlock];

    // Check currentTx range
    if (blockState.currentTx >= blockState.txState.size())
    {
        zklog.error("StateManager64::finishBlock() found blockState.currentTx=" + to_string(blockState.currentTx) + " >= blockState.txState.size=" + to_string(blockState.txState.size()) + " batchUUID=" + batchUUID + " stateRoot=" + stateRoot + " persistence=" + persistence2string(persistence));
        Unlock();
        return ZKR_STATE_MANAGER;
    }

    // Get a reference to the tx state
    TxState64 &txState = blockState.txState[blockState.currentTx];
    TxPersistenceState64 &txPersistenceState = txState.persistence[persistence];


    // This is the happy path case: the last tx
    if (txPersistenceState.newStateRoot == stateRoot)
    {
        blockState.currentStateRoot = stateRoot;
    }

    // If it ended with the same state, activity can be discarded
    else if (txPersistenceState.oldStateRoot == stateRoot)
    {
        if (config.stateManagerPurge)
        {
            // The block ended up with the same state root as the beginning, so we can delete all data
            blockState.txState.clear();
            blockState.currentStateRoot = stateRoot;
            blockState.currentTx = 0;
        }
    }
    else
    {
        if (config.stateManagerPurge)
        {
            // Search for the point at which we reach this state, and delete the rest
            bool bFound = false;
            uint64_t i=0;
            uint64_t txStateSize = blockState.txState.size();
            for (i=0; i<txStateSize; i++)
            {
                if (!bFound && blockState.txState[i].persistence[persistence].oldStateRoot == stateRoot)
                {
                    bFound = true;
                    break;
                }
            }
            if (bFound)
            {
                blockState.currentStateRoot = stateRoot;
                blockState.currentTx = (i == 0) ? 0 : i-1;
                for (; i<txStateSize; i++)
                {
                    blockState.txState.pop_back();
                }
            }
        }
    }
    
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("finishBlock", TimeDiff(t));
#endif

    Unlock();

    return ZKR_SUCCESS;
}

zkresult StateManager64::purgeBatch (const string &batchUUID, BatchState64 &batchState, const Persistence _persistence)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t, t2;
    gettimeofday(&t, NULL);
#endif

    zkassert(!batchState.currentStateRoot.empty());
    string &newStateRoot = batchState.currentStateRoot;
    zkassert(!batchState.oldStateRoot.empty());

    //string newStateRoot = NormalizeToNFormat(_newStateRoot, 64);

    //TimerStart(STATE_MANAGER_PURGE_BATCH);

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::purgeBatch() batchUUID=" + batchUUID + " newStateRoot=" + batchState.currentStateRoot + " persistence=" + persistence2string(_persistence));
#endif

    // For every TX, track backwards from newStateRoot to oldStateRoot, marking sub-states as valid

    //Lock();

    //zkresult zkr;

    //print(false);

    // Find batch state for this uuid
    /*unordered_map<string, BatchState64>::iterator it;
    it = state.find(batchUUID);
    if (it == state.end())
    {
        zklog.error("StateManager::purgeBatch() found no batch state for batch UUID=" + batchUUID + "; normal if no SMT activity happened");

        //TimerStopAndLog(STATE_MANAGER_FLUSH);

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        //timeMetricStorage.add("purgeBatch UUID not found", TimeDiff(t));
        //timeMetricStorage.print("State Manager calls");
#endif
        //Unlock();
        return ZKR_STATE_MANAGER;
    }
    BatchState64 &batchState = it->second;*/

    ///////////////////////////
    // Delete invalid blocks //
    ///////////////////////////

    // Simple case: TX was cancelled (e.g. OOC) and state root does not change, so clear blocks
    if (config.stateManagerPurge && (newStateRoot == batchState.oldStateRoot))
    {
        batchState.blockState.clear();
        batchState.currentBlock = 0;
        batchState.currentStateRoot = batchState.oldStateRoot;
    }

    if (config.stateManagerPurge && !batchState.blockState.empty() && !batchState.oldStateRoot.empty())
    {

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        gettimeofday(&t2, NULL);
#endif

        // Search for the first block that starts at the new state root
        uint64_t firstBlock;
        bool firstBlockFound = false;
        for (firstBlock = 0; firstBlock < batchState.blockState.size(); firstBlock++)
        {
            if (batchState.blockState[firstBlock].oldStateRoot == newStateRoot)
            {
                firstBlockFound = true;
                break;
            }
        }

        // If we found it, delete the rest of blocks
        if (firstBlockFound)
        {
            // Delete this block, and the next blocks
            while (batchState.blockState.size() > (firstBlock + 1))
            {
                batchState.blockState.pop_back();
            }
        }

        // Search for the last block that ends at the new state root
        if (!batchState.blockState.empty())
        {
            int64_t lastBlock;
            bool lastBlockFound = false;
            for (lastBlock = (batchState.blockState.size() - 1); lastBlock >= 0; lastBlock--)
            {
                if (batchState.blockState[lastBlock].currentStateRoot == newStateRoot)
                {
                    lastBlockFound = true;
                    break;
                }
            }
            if (!lastBlockFound)
            {
                zklog.error("StateManager64::purgeBatch() could not find a block state that ends with newStateRoot=" + newStateRoot + " batchUUID=" + batchUUID);
                //Unlock();
                return ZKR_STATE_MANAGER;
            }

            // Delete all previous blocks not belonging to the state root chain
            string currentStateRoot = batchState.blockState[lastBlock].oldStateRoot;
            for (int64_t block = lastBlock - 1; block >= 0; block--)
            {
                if (batchState.blockState[block].currentStateRoot == currentStateRoot)
                {
                    currentStateRoot = batchState.blockState[block].oldStateRoot;
                    continue;
                }
                batchState.blockState.erase(batchState.blockState.begin() + block);
            }

            // Check that we reached the expected batch old state root
            if (batchState.blockState[0].oldStateRoot != batchState.oldStateRoot)
            {
                zklog.error("StateManager64::purgeBatch() could not find a block state that starts with oldStateRoot=" + batchState.oldStateRoot + " batchUUID=" + batchUUID);
                //Unlock();
                return ZKR_STATE_MANAGER;
            }
        }

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        batchState.timeMetricStorage.add("purge blocks", TimeDiff(t2));
#endif
    }

    // Data to write to database
    //unordered_map<string, vector<Goldilocks::Element>> dbWriteNodes;
    string lastNewStateRoot;

    // For all blocks
    for (uint64_t block=0; block<batchState.blockState.size(); block++)
    {
        BlockState64 &blockState = batchState.blockState[block];

        // Delete invalid transactions

        // For all tx sub-states, purge the data to write
        for (uint64_t tx=0; tx<blockState.txState.size(); tx++)
        {
            for (uint64_t persistence = 0; persistence < PERSISTENCE_SIZE; persistence++)
            {
                TxState64 &txState = blockState.txState[tx];

                // Temporary data can be deleted at the end of a batch
                if ((persistence == PERSISTENCE_TEMPORARY) || (persistence == PERSISTENCE_TEMPORARY_HASH))
                {
                    txState.persistence[persistence].subState.clear();
                    txState.persistence[persistence].currentSubState = 0;
                    continue;
                }

                // If there's no data, there's nothing to do
                if (txState.persistence[persistence].subState.size() == 0)
                {
                    continue;
                }

                // Check that current sub-state newStateRoot matches the TX one
                if (txState.persistence[persistence].subState[txState.persistence[persistence].currentSubState].newStateRoot != txState.persistence[persistence].newStateRoot)
                {
                    zklog.error("StateManager64::purgeBatch() found inconsistent new state roots: batchUUID=" + batchUUID +
                        " newStateRoot=" + newStateRoot +
                        " block=" + to_string(block) +
                        " tx=" + to_string(tx) + " txState.newStateRoot=" + txState.persistence[persistence].newStateRoot +
                        " currentSubState=" + to_string(txState.persistence[persistence].currentSubState) +
                        " substate.newStateRoot=" + txState.persistence[persistence].subState[txState.persistence[persistence].currentSubState].newStateRoot);
                        
    #ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                    batchState.timeMetricStorage.add("purgeBatch UUID inconsistent new state roots", TimeDiff(t));
                    batchState.timeMetricStorage.print("State Manager calls");
    #endif
                    //Unlock();
                    return ZKR_STATE_MANAGER;
                }

                //////////////////////////
                // Find valid substates //
                //////////////////////////

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                gettimeofday(&t2, NULL);
#endif
                uint64_t currentSubState = txState.persistence[persistence].currentSubState;
                while (true)
                {
                    txState.persistence[persistence].subState[currentSubState].bValid = true;
                    if (currentSubState == 0)
                    {
                        if (txState.persistence[persistence].subState[currentSubState].oldStateRoot != txState.persistence[persistence].oldStateRoot)
                        {
                            zklog.error("StateManager64::purgeBatch() found inconsistent old state roots: batchUUID=" + batchUUID +
                                " newStateRoot=" + newStateRoot +
                                " block=" + to_string(block) +
                                " tx=" + to_string(tx) + " txState.oldStateRoot=" + txState.persistence[persistence].oldStateRoot +
                                " currentSubState=" + to_string(txState.persistence[persistence].currentSubState) +
                                " substate.oldStateRoot=" + txState.persistence[persistence].subState[currentSubState].oldStateRoot);

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                            batchState.timeMetricStorage.add("purgeBatch UUID inconsistent old state roots", TimeDiff(t));
                            batchState.timeMetricStorage.print("State Manager calls");
#endif
                            //Unlock();
                            return ZKR_STATE_MANAGER;
                        }
                        break;
                    }
                    uint64_t previousSubState = txState.persistence[persistence].subState[currentSubState].previousSubState;
                    if (txState.persistence[persistence].subState[previousSubState].newStateRoot == txState.persistence[persistence].subState[currentSubState].oldStateRoot)
                    {
                        currentSubState = previousSubState;
                        continue;
                    }

                    // Search for the previous state
                    uint64_t i=0;
                    for (; i<currentSubState; i++)
                    {
                        if (txState.persistence[persistence].subState[i].newStateRoot == txState.persistence[persistence].subState[currentSubState].oldStateRoot)
                        {
                            previousSubState = i;
                            break;
                        }
                    }
                    if (i == currentSubState)
                    {
                        // If the origin of this sub-state is the tx old state root, then we are done
                        if (txState.persistence[persistence].subState[currentSubState].oldStateRoot == txState.persistence[persistence].oldStateRoot)
                        {
                            break;
                        }

                        // Otherwise, we could not find a sub-state that connects to this one
                        zklog.error("StateManager64::purgeBatch() could not find previous tx sub-state: batchUUID=" + batchUUID +
                            " newStateRoot=" + newStateRoot +
                            " block=" + to_string(block) +
                            " tx=" + to_string(tx) +
                            " txState.oldStateRoot=" + txState.persistence[persistence].oldStateRoot +
                            " currentSubState=" + to_string(txState.persistence[persistence].currentSubState) +
                            " substate.oldStateRoot=" + txState.persistence[persistence].subState[currentSubState].oldStateRoot);
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                        batchState.timeMetricStorage.add("purgeBatch UUID cannot find previous tx sub-state", TimeDiff(t));
                        batchState.timeMetricStorage.print("State Manager calls");
#endif
                        //Unlock();
                        return ZKR_STATE_MANAGER;
                    }
                    currentSubState = previousSubState;
                }
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                batchState.timeMetricStorage.add("find valid substates", TimeDiff(t2));
#endif

                // Delete invalid sub-states
                for (int64_t ss = txState.persistence[persistence].subState.size() - 1; ss >=0; ss--)
                {
                    if (!txState.persistence[persistence].subState[ss].bValid)
                    {
                        txState.persistence[persistence].subState.erase(txState.persistence[persistence].subState.begin() + ss);
                    }
                }

                /////////////////////////////////
                // Load data to write database //
                /////////////////////////////////
/*
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                gettimeofday(&t2, NULL);
#endif

                // For all sub-states
                for (uint64_t ss = 0; ss < txState.persistence[persistence].subState.size(); ss++)
                {
                    // Skip invalid sub-states (if purge is active)
                    if (config.stateManagerPurge &&
                        ( !txState.persistence[persistence].subState[ss].bValid ||
                          (txState.persistence[persistence].subState[ss].oldStateRoot == txState.persistence[persistence].subState[ss].newStateRoot) ) )
                    {
                        continue;
                    }

                    // Add node keys to dbWriteNodes
                    //dbWriteNodes.insert( txState.persistence[persistence].subState[ss].dbWrite.begin(),
                    //                     txState.persistence[persistence].subState[ss].dbWrite.end());

                    // Copy new state root
                    lastNewStateRoot = txState.persistence[persistence].newStateRoot;
                }

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                batchState.timeMetricStorage.add("load data to write to DB", TimeDiff(t2));
#endif
*/
/*
                ///////////////////////////////////////////
                // Write programs of this TX to database //
                ///////////////////////////////////////////

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                gettimeofday(&t2, NULL);
#endif
                // For all programs in dbWritePrograms
                unordered_map<string, vector<uint8_t>>::const_iterator writeIt;
                for ( writeIt = txState.persistence[persistence].dbPrograms.begin();
                      writeIt != txState.persistence[persistence].dbPrograms.end();
                      writeIt++ )
                {
                    // Call db.setProgram
                    zkr = db.setProgram(writeIt->first, writeIt->second, persistence == PERSISTENCE_DATABASE ? 1 : 0);
                    if (zkr != ZKR_SUCCESS)
                    {
                        zklog.error("StateManager64::flush() failed calling db.writeProgram() result=" + zkresult2string(zkr));
                        state.erase(it);

                        //TimerStopAndLog(STATE_MANAGER_FLUSH);

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                        batchState.timeMetricStorage.add("flush error db.writeProgram", TimeDiff(t));
                        batchState.timeMetricStorage.print("State Manager calls");
#endif
                        Unlock();
                        return zkr;
                    }
                }
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                batchState.timeMetricStorage.add("db.setProgram", TimeDiff(t2));
#endif
*/
            }
        }
    }

    // Write nodes to database
    /*unordered_map<string, vector<Goldilocks::Element>>::const_iterator writeIt;
    for (writeIt = dbWriteNodes.begin(); writeIt != dbWriteNodes.end(); writeIt++)
    {
        zkr = db.write(writeIt->first, NULL, writeIt->second, _persistence == PERSISTENCE_DATABASE ? 1 : 0);
        if (zkr != ZKR_SUCCESS)
        {
            zklog.error("StateManager64::flush() failed calling db.write() result=" + zkresult2string(zkr));
            state.erase(it);

            //TimerStopAndLog(STATE_MANAGER_FLUSH);

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
            batchState.timeMetricStorage.add("flush error db.write", TimeDiff(t));
            batchState.timeMetricStorage.print("State Manager calls");
#endif
            Unlock();
            return zkr;
        }
    }*/

    // Write last new state root to database
    /*if (!lastNewStateRoot.empty())
    {
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        gettimeofday(&t2, NULL);
#endif
        // Convert string to field element array
        Goldilocks::Element newStateRootFea[4];
        string2fea(fr, lastNewStateRoot, newStateRootFea);

        // Call db.updateStateRoot()
        zkr = db.updateStateRoot(newStateRootFea);
        if (zkr != ZKR_SUCCESS)
        {
            zklog.error("StateManager64::flush() failed calling db.updateStateRoot() result=" + zkresult2string(zkr));
            state.erase(it);

            //TimerStopAndLog(STATE_MANAGER_FLUSH);

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
            batchState.timeMetricStorage.add("flush error db.updateStateRoot", TimeDiff(t));
            batchState.timeMetricStorage.print("State Manager calls");
#endif
            Unlock();
            return zkr;
        }

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        batchState.timeMetricStorage.add("db.updateStateRoot", TimeDiff(t2));
#endif
    }*/

    // Flush written data to remote database
/*
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    gettimeofday(&t2, NULL);
#endif
    zkr = db.flush(flushId, lastSentFlushId);
    if (zkr != ZKR_SUCCESS)
    {
        zklog.error("StateManager64::flush() failed calling db.flush() result=" + zkresult2string(zkr));
    }
*/
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    //batchState.timeMetricStorage.add("db.flush", TimeDiff(t2));
    batchState.timeMetricStorage.add("purgeBatch success", TimeDiff(t));
    batchState.timeMetricStorage.print("State Manager calls");
#endif
    
    // Delete this batch UUID state
    //state.erase(it);

    //Unlock();

    //TimerStopAndLog(STATE_MANAGER_FLUSH);

    return ZKR_SUCCESS;
}

zkresult StateManager64::consolidateState(const string &_virtualStateRoot, const Persistence persistence, string & consolidatedStateRoot, Database64 &db, uint64_t &flushId, uint64_t &lastSentFlushId)
{
    zkresult zkr;

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    TimerStart(STATE_MANAGER_CONSOLIDATE_STATE);

    print(true);

    // Format the new state root
    string virtualStateRoot = NormalizeToNFormat(_virtualStateRoot, 64);

    if (!isVirtualStateRoot(virtualStateRoot) && (virtualStateRoot == lastConsolidatedStateRootString))
    {
        zklog.info("StateManager64::consolidateState() called with non-virtual virtualStateRoot=" + virtualStateRoot + " that matches the lastConsolidatedStateRootString, so nothing to do");
        consolidatedStateRoot = virtualStateRoot;

        // Call flush and get the flush ID
        zkr = db.flush(flushId, lastSentFlushId);
        if (zkr != ZKR_SUCCESS)
        {
            zklog.error("StateManager64::consolidateState() failed calling db.flush() result=" + zkresult2string(zkr));
        }

        return zkr;
    }

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::consolidateState() virtualStateRoot=" + virtualStateRoot);
#endif

    // For every TX, track backwards from newStateRoot to oldStateRoot, marking sub-states as valid

    Lock();

    //print(false);

    // Find the batch that ends up with the virtual state root
    uint64_t virtualStatePosition = 0;
    string oldStateRoot;
    unordered_map<string, BatchState64>::iterator it;
    for (virtualStatePosition = 0; virtualStatePosition < stateOrder.size(); virtualStatePosition++)
    {
        it = state.find(stateOrder[virtualStatePosition]);
        if (it == state.end())
        {
            zklog.error("StateManager64::consolidateState() found unmatching state i=" + to_string(virtualStatePosition) + " batchUUI=" + stateOrder[virtualStatePosition]);
            TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);        
            Unlock();
            return ZKR_STATE_MANAGER;
        }
        if (it->second.currentStateRoot == virtualStateRoot)
        {
            // Purge the batch
            zkr = purgeBatch(it->first, it->second, persistence);
            if (zkr != ZKR_SUCCESS)
            {
                zklog.error("StateManager64::consolidateState() failed calling purgeBatch state=" + stateOrder[virtualStatePosition] + " error=" + zkresult2string(zkr));
                TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);        
                Unlock();
                return ZKR_STATE_MANAGER;
            }

            print(true);

            // Update the old state root
            oldStateRoot = it->second.oldStateRoot;

            break;
        }
    }
    if (virtualStatePosition == stateOrder.size())
    {
        zklog.error("StateManager64::consolidateState() could not find a matching virtual state=" + virtualStateRoot);
        TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);        
        Unlock();
        return ZKR_STATE_MANAGER;
    }

    // Determine the chain of state roots (i.e. previous batches) that leads to newStateRoot
    // Delete previous batches that are not part of the chain

    for (int64_t i = (int64_t)virtualStatePosition - 1; i >= 0; i--)
    {
        // Find the batch state corresponding to this position
        it = state.find(stateOrder[i]);
        if (it == state.end())
        {
            zklog.error("StateManager64::consolidateState() could not find a matching virtual state=" + stateOrder[i]);
            TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);        
            Unlock();
            return ZKR_STATE_MANAGER;
        }

        // If this state is part of the state chain, purge it and continue searching
        if (oldStateRoot == it->second.currentStateRoot)
        {
            // Update the old state root
            oldStateRoot = it->second.oldStateRoot;

            continue;
        }

        // Otherwise, we must delete this state, and shift the virtual state position
        state.erase(it);
        stateOrder.erase(stateOrder.begin() + i);
        virtualStatePosition--;
    }

    // Calculate the real state roots, and write them to the database

    // We will store here the latest tx new state root
    Goldilocks::Element newRoot[4];

    // For all batches in the state root chain

    for (uint64_t batch = 0; batch <= virtualStatePosition; batch++)
    {
        // Find the batch state corresponding to this position
        it = state.find(stateOrder[batch]);
        if (it == state.end())
        {
            zklog.error("StateManager64::consolidateState() could not find a matching virtual state=" + stateOrder[batch]);
            TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);        
            Unlock();
            return ZKR_STATE_MANAGER;
        }

        BatchState64 &batchState = state[stateOrder[batch]];

        // For all blocks
        for (uint64_t block = 0; block < batchState.blockState.size(); block++)
        {
            BlockState64 &blockState = batchState.blockState[block];

            if (batch > 0)
            {
                string newStateRootString = fea2string(fr, newRoot);
                batchState.oldStateRoot = newStateRootString;
                if (blockState.txState.size() > 0)
                {
                    blockState.txState[0].persistence[persistence].oldStateRoot = newStateRootString;
                }
            }

            // For all transactions
            for (uint64_t tx = 0; tx < blockState.txState.size(); tx++)
            {
                // Get a reference to the current transaction state
                TxState64 &txState = blockState.txState[tx];

                // Get old state root for this tx
                Goldilocks::Element oldRoot[4];
                string2fea(fr, txState.persistence[persistence].oldStateRoot, oldRoot);

                // Get the key-values for this tx
                vector<KeyValue> keyValues;
                for (uint64_t i=0; i<txState.persistence[persistence].subState.size(); i++)
                {
                    unordered_map<string, mpz_class> &dbWrite = txState.persistence[persistence].subState[i].dbWrite;
                    unordered_map<string, mpz_class>::const_iterator it;
                    for (it = dbWrite.begin(); it != dbWrite.end(); it++)
                    {
                        KeyValue keyValue;
                        string2fea(fr, it->first, keyValue.key);
                        keyValue.value = it->second;
                        keyValues.emplace_back(keyValue);
                        zklog.info("StateManager64::consolidateState() storing key=" + it->first + " value=" + it->second.get_str(16));
                    }
                }

                // Call WriteTree and get the new state root
                zkr = db.WriteTree(oldRoot, keyValues, newRoot, persistence == PERSISTENCE_DATABASE ? true : false);
                if (zkr != ZKR_SUCCESS)
                {
                    zklog.error("StateManager64::consolidateState() failed calling WriteTree zkr=" + zkresult2string(zkr) +
                                " tx=" + to_string(tx) +
                                " txState.oldStateRoot=" + txState.persistence[persistence].oldStateRoot);
        #ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                    batchState.timeMetricStorage.add("consolidateState WriteTree failed", TimeDiff(t));
                    batchState.timeMetricStorage.print("State Manager calls");
        #endif
                    Unlock();
                    return ZKR_STATE_MANAGER;
                }

                // Save the real state root of this tx
                string newRootString = fea2string(fr, newRoot);
                txState.persistence[persistence].newStateRoot = newRootString;

                // Save the old state root of the next tx, if any
                if (tx < blockState.txState.size() - 1)
                {
                    blockState.txState[tx+1].persistence[persistence].oldStateRoot = newRootString;
                }
                // If this is the last tx, then save the new state root of the batch
                else
                {
                    blockState.currentStateRoot = newRootString;
                }

                // Send the programs to database
                unordered_map<string, vector<uint8_t>>::const_iterator itProgram;
                for (itProgram = txState.persistence[persistence].dbPrograms.begin(); itProgram != txState.persistence[persistence].dbPrograms.end(); itProgram++)
                {
                    zkr = db.setProgram(itProgram->first, itProgram->second, persistence == PERSISTENCE_DATABASE ? true : false);
                    if (zkr != ZKR_SUCCESS)
                    {
                        zklog.error("StateManager64::consolidateState() failed calling db.setProgram zkr=" + zkresult2string(zkr) +
                                    " tx=" + to_string(tx) +
                                    " txState.oldStateRoot=" + txState.persistence[persistence].oldStateRoot);
            #ifdef LOG_TIME_STATISTICS_STATE_MANAGER
                        batchState.timeMetricStorage.add("consolidateState db.setProgram failed", TimeDiff(t));
                        batchState.timeMetricStorage.print("State Manager calls");
            #endif
                        Unlock();
                        return ZKR_STATE_MANAGER;
                    }
                }

            } // For all transactions

        } // For all blocks

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        batchState.timeMetricStorage.add("consolidateState success", TimeDiff(t));
        batchState.timeMetricStorage.print("State Manager calls");
#endif

    } // For all batches

    // Return the consolidated state root
    consolidatedStateRoot = fea2string(fr, newRoot);

    // Copy it to use it when reading a KV that is not in the StateManager,
    // and we have to read it from database using a consolidated state root
    lastConsolidatedStateRoot[0] = newRoot[0];
    lastConsolidatedStateRoot[1] = newRoot[1];
    lastConsolidatedStateRoot[2] = newRoot[2];
    lastConsolidatedStateRoot[3] = newRoot[3];
    lastConsolidatedStateRootString = consolidatedStateRoot;

    // Call flush and get the flush ID
    zkr = db.flush(flushId, lastSentFlushId);
    if (zkr != ZKR_SUCCESS)
    {
        zklog.error("StateManager64::consolidateState() failed calling db.flush() result=" + zkresult2string(zkr));
    }

    // Delete all batches of the virtual state chain
    for (int64_t i = (int64_t)virtualStatePosition; i >= 0; i--)
    {
        // Find the batch state corresponding to this position
        it = state.find(stateOrder[i]);
        if (it == state.end())
        {
            zklog.error("StateManager64::consolidateState() could not find a matching virtual state=" + stateOrder[i]);
            TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);        
            Unlock();
            return ZKR_STATE_MANAGER;
        }

        // Delete this state, and shift the virtual state position
        state.erase(it);
        stateOrder.erase(stateOrder.begin() + i);
    }

    Unlock();

    //db.PrintTree("");

    TimerStopAndLog(STATE_MANAGER_CONSOLIDATE_STATE);

    return zkr;
}

zkresult StateManager64::cancelBatch (const string &batchUUID)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    TimerStart(STATE_MANAGER_CANCEL_BATCH);

#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::cancelBatch() batchUUID=" + batchUUID);
#endif

    Lock();

    // Find batch state for this uuid
    unordered_map<string, BatchState64>::iterator it;
    it = state.find(batchUUID);
    if (it == state.end())
    {
        zklog.warning("StateManager64::cancelBatch() found no batch state for batch UUID=" + batchUUID + "; normal if no SMT activity happened");
        TimerStopAndLog(STATE_MANAGER_CANCEL_BATCH);
        Unlock();
        return ZKR_STATE_MANAGER;
    }
    state.erase(it);

    Unlock();

    TimerStopAndLog(STATE_MANAGER_CANCEL_BATCH);

    return ZKR_SUCCESS;
}

void StateManager64::print (bool bDbContent)
{
    uint64_t totalDbWrites[PERSISTENCE_SIZE] = {0, 0, 0, 0};
    zklog.info("StateManager64::print():");
    zklog.info("state.size=" + to_string(state.size()));
    unordered_map<string, BatchState64>::const_iterator stateIt;
    uint64_t batchStateCounter = 0;
    for (stateIt = state.begin(); stateIt != state.end(); stateIt++)
    {
        const BatchState64 &batchState = stateIt->second;
        zklog.info("  batchState=" + to_string(batchStateCounter));
        batchStateCounter++;
        zklog.info("  BatchUUID=" + stateIt->first);
        zklog.info("  oldStateRoot=" + batchState.oldStateRoot);
        zklog.info("  currentStateRoot=" + batchState.currentStateRoot);
        zklog.info("  currentBlock=" + to_string(batchState.currentBlock));

        for (uint64_t block=0; block<batchState.blockState.size(); block++)
        {
            zklog.info("    BLOCK=" + to_string(block) + "/" + to_string(batchState.blockState.size()));
            const BlockState64 &blockState = batchState.blockState[block];

            zklog.info("    oldStateRoot=" + blockState.oldStateRoot);
            zklog.info("    currentStateRoot=" + blockState.currentStateRoot);
            zklog.info("    currentTx=" + to_string(blockState.currentTx));       

            for (uint64_t tx=0; tx<blockState.txState.size(); tx++)
            {
                zklog.info("      TX=" + to_string(tx) + "/" + to_string(blockState.txState.size()));
                const TxState64 &txState = blockState.txState[tx];

                for (uint64_t persistence = 0; persistence < PERSISTENCE_SIZE; persistence++)
                {
                    //if (persistence != PERSISTENCE_DATABASE) continue;
                    zklog.info("        persistence=" + to_string(persistence) + "=" + persistence2string((Persistence)persistence));
                    zklog.info("          oldStateRoot=" + txState.persistence[persistence].oldStateRoot);
                    zklog.info("          newStateRoot=" + txState.persistence[persistence].newStateRoot);
                    zklog.info("          currentSubState=" + to_string(txState.persistence[persistence].currentSubState));
                    zklog.info("          txSubState.size=" + to_string(txState.persistence[persistence].subState.size()));
                    for (uint64_t i=0; i<txState.persistence[persistence].subState.size(); i++)
                    {
                        const TxSubState64 &txSubState = txState.persistence[persistence].subState[i];
                        zklog.info("            txSubState=" + to_string(i));
                        zklog.info("              oldStateRoot=" + txSubState.oldStateRoot);
                        zklog.info("              newStateRoot=" + txSubState.newStateRoot);
                        zklog.info("              valid=" + to_string(txSubState.bValid));
                        zklog.info("              previousSubState=" + to_string(txSubState.previousSubState));
                        zklog.info("              dbWrite.size=" + to_string(txSubState.dbWrite.size()));

                        totalDbWrites[persistence] += txSubState.dbWrite.size();
                        if (bDbContent)
                        {
                            unordered_map<string, mpz_class>::const_iterator dbIt;
                            for (dbIt = txSubState.dbWrite.begin(); dbIt != txSubState.dbWrite.end(); dbIt++)
                            {
                                zklog.info("                " + dbIt->first);
                            }
                        }
                    }
                    zklog.info("          dbWritePrograms.size=" + to_string(txState.persistence[persistence].dbPrograms.size()));
                    if (bDbContent)
                    {
                        unordered_map<string, vector<uint8_t>>::const_iterator dbIt;
                        for (dbIt = txState.persistence[persistence].dbPrograms.begin(); dbIt != txState.persistence[persistence].dbPrograms.end(); dbIt++)
                        {
                            zklog.info("                " + dbIt->first);
                        }
                    }
                }
            }
        }
    }

    uint64_t totalWrites = 0;
    for (uint64_t persistence=0; persistence<PERSISTENCE_SIZE; persistence++)
    {
        zklog.info("total db writes[" + persistence2string((Persistence)persistence) + "]=" + to_string(totalDbWrites[persistence]));
        totalWrites += totalDbWrites[persistence];
    }
    zklog.info("total writes=" + to_string(totalWrites));

    zklog.info("stateOrder.size=" + to_string(stateOrder.size()));
    for (uint64_t i=0; i<stateOrder.size(); i++)
    {
        zklog.info("  i=" + to_string(i) + " uuid=" + stateOrder[i]);
    }
}

void StateManager64::getVirtualStateRoot(Goldilocks::Element (&newStateRoot)[4], string &newStateRootString)
{
    lastVirtualStateRoot++;
    newStateRoot[0] = fr.fromU64(lastVirtualStateRoot);
    newStateRoot[1] = fr.zero();
    newStateRoot[2] = fr.zero();
    newStateRoot[3] = fr.zero();
    newStateRootString = fea2string(fr, newStateRoot);
}

bool StateManager64::isVirtualStateRoot(const string &stateRoot)
{
    Goldilocks::Element root[4];
    string2fea(fr, stateRoot, root);
    return fr.isZero(root[1]) && fr.isZero(root[2]) && fr.isZero(root[3]);
}

zkresult StateManager64::set (const string &batchUUID, uint64_t block, uint64_t tx, Database64 &db, const Goldilocks::Element (&oldRoot)[4], const Goldilocks::Element (&key)[4], const mpz_class &value, const Persistence persistence, SmtSetResult &result, DatabaseMap *dbReadLog)
{
#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::set() called with oldRoot=" + fea2string(fr,oldRoot) + " key=" + fea2string(fr,key) + " value=" + value.get_str(16) + " persistent=" + persistence2string(persistence) + " batchUUID=" + batchUUID + " tx=" + to_string(tx));
#endif

    zkresult zkr;

    bool bUseStateManager = config.stateManager && (batchUUID.size() > 0);

    if (bUseStateManager)
    {
        // Set the old state root
        string oldRootString;
        oldRootString = fea2string(fr, oldRoot);
        stateManager64.setOldStateRoot(batchUUID, block, tx, oldRootString, persistence);

        // Write the key-value pair
        string hashString = fea2string(fr, key);
        uint64_t level=0;
        uint64_t stateManagerLevel;
        uint64_t databaseLevel;
        zkr = stateManager64.write(batchUUID, block, tx, hashString, value, persistence, stateManagerLevel);
        if (zkr != ZKR_SUCCESS)
        {
            zklog.error("StateManager64::set() failed calling stateManager.write() key=" + hashString + " result=" + to_string(zkr) + "=" + zkresult2string(zkr));
        }
        else
        {
            zkresult dbzkr = db.readLevel(key, databaseLevel);
            if (dbzkr != ZKR_SUCCESS)
            {
                zklog.error("StateManager64::set() failed calling db.readLevel() key=" + hashString + " result=" + to_string(dbzkr) + "=" + zkresult2string(dbzkr));
                level = 128;
            }
            else
            {
                level = zkmax(stateManagerLevel, databaseLevel);
            }

        }

        // Get a new state root
        Goldilocks::Element newRoot[4]; // TODO: Get a new state root
        string newRootString;
        stateManager64.getVirtualStateRoot(newRoot, newRootString);

        // Set the new sttae root
        stateManager64.setNewStateRoot(batchUUID, block, tx, newRootString, persistence);

        result.newRoot[0] = newRoot[0];
        result.newRoot[1] = newRoot[1];
        result.newRoot[2] = newRoot[2];
        result.newRoot[3] = newRoot[3];
        result.proofHashCounter = level + 2;
    }
    else
    {
        // TODO: implementation
    }

    return ZKR_SUCCESS;
}

zkresult StateManager64::get (const string &batchUUID, Database64 &db, const Goldilocks::Element (&root)[4], const Goldilocks::Element (&key)[4], SmtGetResult &result, DatabaseMap *dbReadLog)
{
#ifdef LOG_STATE_MANAGER
    zklog.info("StateManager64::get() called with root=" + fea2string(fr,root) + " and key=" + fea2string(fr,key));
#endif

    bool bUseStateManager = config.stateManager && (batchUUID.size() > 0);

    string keyString = fea2string(fr, key);
    mpz_class value = 0;
    zkresult zkr = ZKR_UNSPECIFIED;
    uint64_t stateManagerLevel = 0;
    uint64_t databaseLevel = 0;
    uint64_t level = 0;
    if (bUseStateManager)
    {
        zkr = stateManager64.read(batchUUID, keyString, value, stateManagerLevel, dbReadLog);
        if (zkr == ZKR_SUCCESS)
        {
            zkresult dbzkr = db.readLevel(key, databaseLevel);
            if (dbzkr != ZKR_SUCCESS)
            {
                zklog.error("StateManager64::get() failed calling db.readLevel() result=" + zkresult2string(dbzkr));
                level = 128;
            }
            else
            {
                level = zkmax(stateManagerLevel, databaseLevel);
            }
        }
        else if (zkr != ZKR_DB_KEY_NOT_FOUND)
        {
            zklog.error("StateManager64::get() failed calling stateManager64.read() error=" + zkresult2string(zkr) + " root=" + fea2string(fr, lastConsolidatedStateRoot) + " key=" + fea2string(fr, key));
            return zkr;
        }
    }
    if ((zkr != ZKR_SUCCESS) && !feaIsZero(lastConsolidatedStateRoot))
    {
        zkr = db.readKV(lastConsolidatedStateRoot, key, value, databaseLevel, dbReadLog);
        if ((zkr != ZKR_SUCCESS) && (zkr != ZKR_DB_KEY_NOT_FOUND))
        {
            zklog.error("StateManager64::get() failed calling db.readKV() error=" + zkresult2string(zkr) + " root=" + fea2string(fr, lastConsolidatedStateRoot) + " key=" + fea2string(fr, key));
            return zkr;
        }
        level = databaseLevel;
    }
    if (zkr != ZKR_SUCCESS)
    {
        // If key was not found, it's value is 0
        value = 0;

        uint64_t databaseLevel;
        zkr = db.readLevel(key, databaseLevel);
        if (zkr != ZKR_SUCCESS)
        {
            zklog.error("StateManager64::get() db.readLevel error=" + zkresult2string(zkr) + " root=" + fea2string(fr, lastConsolidatedStateRoot) + " key=" + fea2string(fr, key));
            return zkr;
        }
        level = zkmax(databaseLevel, stateManagerLevel);
    }
    
    result.value = value;
    result.proofHashCounter = level + 2;

    return ZKR_SUCCESS;
}

zkresult StateManager64::writeProgram (const string &batchUUID, uint64_t block, uint64_t tx, const string &_key, const vector<uint8_t> &value, const Persistence persistence)
{
#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    struct timeval t;
    gettimeofday(&t, NULL);
#endif

    // Normalize key format
    string key = NormalizeToNFormat(_key, 64);
    key = stringToLower(key);

#ifdef LOG_STATE_MANAGER_WRITE_PROGRAM
    zklog.info("StateManager64::writeProgram() batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " key=" + key + " persistence=" + persistence2string(persistence));
#endif

    // Check persistence range
    if (persistence >= PERSISTENCE_SIZE)
    {
        zklog.error("StateManager64::writeProgram() wrong persistence batchUUID=" + batchUUID + " block=" + to_string(block) + " tx=" + to_string(tx) + " key=" + key + " persistence=" + persistence2string(persistence));
        return ZKR_STATE_MANAGER;
    }

    Lock();

    // Find batch state for this uuid, or create it if it does not exist
    unordered_map<string, BatchState64>::iterator it;
    it = state.find(batchUUID);
    if (it == state.end())
    {
        BatchState64 batchState;
        state[batchUUID] = batchState;
        stateOrder.emplace_back(batchUUID);
        it = state.find(batchUUID);
        zkassert(it != state.end());
    }
    BatchState64 &batchState = it->second;

    // Detect first set programs before first block, one per TX, and ignore them
    if ((block == 0) && batchState.blockState.empty())
    {
        //zklog.warning("StateManager::writeProgram() ignoring program set before first block key=" + key);
        Unlock();
        return ZKR_SUCCESS;
    }

    // Check block range
    if (block >= batchState.blockState.size())
    {
        zklog.error("StateManager64::writeProgram() got block=" + to_string(block) + " bigger than blockState size=" + to_string(it->second.blockState.size()));
        Unlock();
        return ZKR_STATE_MANAGER;
    }
    BlockState64 &blockState = batchState.blockState[block];

    // Check tx range
    if (tx > blockState.txState.size())
    {
        zklog.error("StateManager64::writeProgram() got tx=" + to_string(tx) + " bigger than txState size=" + to_string(blockState.txState.size()));
        Unlock();
        return ZKR_STATE_MANAGER;
    }

    // Create TxState, if not existing
    if (tx == blockState.txState.size())
    {
        TxState64 aux;
        aux.persistence[persistence].oldStateRoot = it->second.currentStateRoot;
        blockState.txState.emplace_back(aux);
    }
    TxState64 &txState = blockState.txState[tx];

    // Add to sub-state
    txState.persistence[persistence].dbPrograms[key] = value;
    
    // Add to common write pool to speed up read
    batchState.dbPrograms[key] = value;

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("writePrograms", TimeDiff(t));
#endif

    Unlock();

    return ZKR_SUCCESS;
}

zkresult StateManager64::readProgram (const string &batchUUID, const string &key, vector<uint8_t> &value, DatabaseMap *dbReadLog)
{
    struct timeval t;
    gettimeofday(&t, NULL);

    Lock();

    // Find batch state for this uuid
    unordered_map<string, BatchState64>::iterator it;
    it = state.find(batchUUID);
    if (it == state.end())
    {
        //zklog.error("StateManager::readProgram() found no batch state for batch UUID=" + batchUUID);
        Unlock();
        return ZKR_DB_KEY_NOT_FOUND;
    }
    BatchState64 &batchState = it->second;

    // Search in the common write list
    unordered_map<string, vector<uint8_t>>::iterator dbIt;
    dbIt = batchState.dbPrograms.find(key);
    if (dbIt != batchState.dbPrograms.end())
    {
        value = dbIt->second;
                        
        // Add to the read log
        if (dbReadLog != NULL) dbReadLog->add(key, value, true, TimeDiff(t));

#ifdef LOG_STATE_MANAGER_READ
        zklog.info("StateManager64::readProgram() batchUUID=" + batchUUID + " key=" + key);
#endif

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
        batchState.timeMetricStorage.add("readProgram success", TimeDiff(t));
#endif
        Unlock();

        return ZKR_SUCCESS;
    }

#ifdef LOG_TIME_STATISTICS_STATE_MANAGER
    batchState.timeMetricStorage.add("readProgram not found", TimeDiff(t));
#endif

    Unlock();

    return ZKR_DB_KEY_NOT_FOUND;
}